<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Copyright (c) 2005 Stijn van Dongen -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
body {
text-align: justify;
color: #001111;
background: white;
margin-left: 8%;
margin-right: 8%;
font-family: Helvetica, Univers, Verdana, sans-serif;
}
p.default {
font-family: Helvetica, Univers, Verdana, sans-serif;
text-align: justify;
}
p.L53 { font-size: 30pt; }
p.L52 { font-size: 20pt; }
p.L51 { font-size: 15pt; }
p.L50 { font-size: 12pt; }
p.L49 { font-size: 10pt; }
p.L48 { font-size: 9pt; }
p.L47 { font-size: 8pt; }
td {
font-family: Helvetica, Univers, Verdana, sans-serif;
text-align: justify;
}
h3 { margin-top:1em; }
h2 { margin-top:2em; }
.left { text-align: left; align: left; }
.right { text-align: right; align: right; }
.center { text-align: center; align: center; }
a:link { text-decoration: none; }
a:active { text-decoration: none; }
a:visited { text-decoration: none; }
a:link { color: #1111aa; }
a:active { color: #1111aa; }
a:visited { color: #111166; }
a.local:link { color: #11aa11; }
a.local:active { color: #11aa11; }
a.local:visited { color: #116611; }
a.intern:link { color: #1111aa; }
a.intern:active { color: #1111aa; }
a.intern:visited { color: #111166; }
a.extern:link { color: #aa1111; }
a.extern:active { color: #aa1111; }
a.extern:visited { color: #661111; }
a.quiet:link { color: black; }
a.quiet:active { color: black; }
a.quiet:visited { color: black; }
div.copy
{ font-size: 12pt;
font-family: monospace;
text-align: left;
white-space: pre;
margin-left: 2em;
margin-top: 1em;
margin-bottom: 1em;
}
div.indent
{ margin-left: 8%;
margin-right: 0%;
}
</style>
<title>The MCL FAQ</title>
</head>
<body>
<p style="text-align:right">
27 Oct 2005&nbsp;&nbsp;&nbsp;
<a class="local" href="mclfaq.ps"><b>MCL&nbsp;FAQ</b></a>
1.005, 05-300
</p>
<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=48 valign="top" class=left>1.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#name">NAME</a>
</div></td></tr><tr><td width=48 valign="top" class=left>2.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#resources">RESOURCES</a>
</div></td></tr><tr><td width=48 valign="top" class=left>3.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#toc">TOC</a>
</div></td></tr><tr><td width=48 valign="top" class=left>4.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq">FAQ</a>
</div></td></tr><tr><td width=48 valign="top" class=left>5.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#bugs">BUGS</a>
</div></td></tr><tr><td width=48 valign="top" class=left>6.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#author">AUTHOR</a>
</div></td></tr><tr><td width=48 valign="top" class=left>7.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#seealso">SEE ALSO</a>
</div></td></tr><tr><td width=48 valign="top" class=left>8.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#references">REFERENCES</a>
</div></td></tr><tr><td width=48 valign="top" class=left>9.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#notes">NOTES</a>
</div></td></tr>
</table>

</div>

<a name="name"></a>
<h2>NAME</h2>
<p class="default L50" style="margin-bottom:0">
mclfaq - faqs and facts about the MCL cluster algorithm.</p>
<p class="default L50">
MCL refers to the generic MCL algorithm and the MCL process on which the
algorithm is based. <b>mcl</b> refers to the implementation. This FAQ answers
questions related to both. In some places MCL is written where MCL or mcl
can be read. This is the case for example in
<a class="intern" href="#kind">section 3,&nbsp;What kind of graphs</a>.
It should in general be obvious from the context.
<p class="default L50">
This FAQ does not begin to attempt to explain the motivation
and mathematics behind the MCL algorithm - the internals are not
explained. A broad view is given in faq&nbsp;<a class="intern" href="#overview">1.2</a>,
and see also faq&nbsp;<a class="intern" href="#innards">1.5</a> and section <a class="intern" href="#references">REFERENCES</a>.
<p class="default L50">
Some additional sections preceed the actual faq entries.
The TOC section contains a listing of all questions.
<b>Clicking on the number of a question</b>
(where it is answered) will take you to
the corresponding section of the table of contents.

<a name="resources"></a>
<h2>RESOURCES</h2>
<p class="default L50">
The manual pages for all the utilities that come with <b>mcl</b>;
refer to <a class="local" href="mclfamily.html">mclfamily</a> for an overview.
<p class="default L50">
mcl development is discussed on mcl-devel@micans.org,
list information is at
<a class="extern" href="https://lists.micans.org:446/listinfo/mcl-devel">https://lists.micans.org:446/listinfo/mcl-devel</a>.
<p class="default L50">
See the <a class="intern" href="#references">REFERENCES</a> Section for publications detailing the
mathematics behind the MCL algorithm.

<a name="toc"></a>
<h2>TOC</h2>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-general"></a><a class="quiet" href="#general"><b>1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#general"><b>General questions</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-faq1.1"></a> <a class="intern" href="#faq1.1"><b>1.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq1.1"><b>For whom is mcl and for whom is this FAQ?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-overview"></a> <a class="intern" href="#overview"><b>1.2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#overview"><b>What is the relationship between the MCL process, the MCL algorithm, and the 'mcl' implementation?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq1.3"></a> <a class="intern" href="#faq1.3"><b>1.3</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq1.3"><b>What do the letters MCL stand for?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq1.4"></a> <a class="intern" href="#faq1.4"><b>1.4</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq1.4"><b>How could you be so feebleminded to use MCL as abbreviation? Why
is it labeled 'Markov cluster' anyway?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-innards"></a> <a class="intern" href="#innards"><b>1.5</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#innards"><b>Where can I learn about the innards of the MCL algorithm/process?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq1.6"></a> <a class="intern" href="#faq1.6"><b>1.6</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq1.6"><b>For which platforms is mcl available?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-versioning"></a> <a class="intern" href="#versioning"><b>1.7</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#versioning"><b>How does mcl's versioning scheme work?</b></a>
</div></td></tr>
</table>

</div>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-ioformat"></a><a class="quiet" href="#ioformat"><b>2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#ioformat"><b>Input format</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-faq2.1"></a> <a class="intern" href="#faq2.1"><b>2.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq2.1"><b>How can I get my data into the MCL matrix format?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq2.2"></a> <a class="intern" href="#faq2.2"><b>2.2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq2.2"><b>Can I get my graph into MCL format by directly streaming it?</b></a>
</div></td></tr>
</table>

</div>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-kind"></a><a class="quiet" href="#kind"><b>3</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#kind"><b>What kind of graphs</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-faq3.1"></a> <a class="intern" href="#faq3.1"><b>3.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq3.1"><b>What is legal input for MCL?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq3.2"></a> <a class="intern" href="#faq3.2"><b>3.2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq3.2"><b>What is sensible input for MCL?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq3.3"></a> <a class="intern" href="#faq3.3"><b>3.3</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq3.3"><b>Does MCL work for weighted graphs?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq3.4"></a> <a class="intern" href="#faq3.4"><b>3.4</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq3.4"><b>Does MCL work for directed graphs?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq3.5"></a> <a class="intern" href="#faq3.5"><b>3.5</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq3.5"><b>Can MCL work for lattices / directed acyclic graphs / DAGs?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq3.6"></a> <a class="intern" href="#faq3.6"><b>3.6</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq3.6"><b>Does MCL work for tree graphs?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-whatkind"></a> <a class="intern" href="#whatkind"><b>3.7</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#whatkind"><b>For what kind of graphs does MCL work well and for which does it not?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-goodinput"></a> <a class="intern" href="#goodinput"><b>3.8</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#goodinput"><b>What makes a good input graph?
How do I construct the similarities?
How to make them satisfy this Markov condition?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-directedinput"></a> <a class="intern" href="#directedinput"><b>3.9</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#directedinput"><b>My input graph is directed. Is that bad?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq3.10"></a> <a class="intern" href="#faq3.10"><b>3.10</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq3.10"><b>Why does mcl like undirected graphs and why does it
dislike uni-directed graphs so much?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-checksymmetry"></a> <a class="intern" href="#checksymmetry"><b>3.11</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#checksymmetry"><b>How do I check that my graph/matrix is symmetric/undirected?</b></a>
</div></td></tr>
</table>

</div>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-speed"></a><a class="quiet" href="#speed"><b>4</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#speed"><b>Speed and complexity</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-howfast"></a> <a class="intern" href="#howfast"><b>4.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#howfast"><b>How fast is mcl/MCL?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-stats"></a> <a class="intern" href="#stats"><b>4.2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#stats"><b>What statistics are available?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-colsort"></a> <a class="intern" href="#colsort"><b>4.3</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#colsort"><b>Does this implementation need to sort vectors?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-approx"></a> <a class="intern" href="#approx"><b>4.4</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#approx"><b>mcl does not compute the ideal MCL process!</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-elsewhere"></a> <a class="intern" href="#elsewhere"><b>4.5</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#elsewhere"><b>I've read elsewhere that MCL is slow [compared with XYZ]</b></a>
</div></td></tr>
</table>

</div>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-resource"></a><a class="quiet" href="#resource"><b>5</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#resource"><b>Resource tuning / accuracy</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-wdymbrt"></a> <a class="intern" href="#wdymbrt"><b>5.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#wdymbrt"><b>What do you mean by resource tuning?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq5.2"></a> <a class="intern" href="#faq5.2"><b>5.2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq5.2"><b>How do I compute the maximum amount of RAM needed by mcl?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-pcmp"></a> <a class="intern" href="#pcmp"><b>5.3</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#pcmp"><b>How much does the mcl clustering differ from the clustering resulting
from a perfectly computed MCL process?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-enoughresources"></a> <a class="intern" href="#enoughresources"><b>5.4</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#enoughresources"><b>How do I know that I am using enough resources?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-nmap"></a> <a class="intern" href="#nmap"><b>5.5</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#nmap"><b>Where is the mathematical analysis of this mcl pruning strategy?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-qsep"></a> <a class="intern" href="#qsep"><b>5.6</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#qsep"><b>What qualitative statements can be made about the effect of pruning?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq5.7"></a> <a class="intern" href="#faq5.7"><b>5.7</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq5.7"><b>At different high resource levels my clusterings are not identical.
How can I trust the output clustering?</b></a>
</div></td></tr>
</table>

</div>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-granularity"></a><a class="quiet" href="#granularity"><b>6</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#granularity"><b>Tuning cluster granularity</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-faq6.1"></a> <a class="intern" href="#faq6.1"><b>6.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq6.1"><b>How do I tune cluster granularity?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq6.2"></a> <a class="intern" href="#faq6.2"><b>6.2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq6.2"><b>The effect of inflation on cluster granularity.</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-simil_granul"></a> <a class="intern" href="#simil_granul"><b>6.3</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#simil_granul"><b>The effect of similarity distribution homogeneity on cluster granularity.</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq6.4"></a> <a class="intern" href="#faq6.4"><b>6.4</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq6.4"><b>The effect of initial centering on cluster granularity.</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-faq6.5"></a> <a class="intern" href="#faq6.5"><b>6.5</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq6.5"><b>How to implement two-level approaches using mcl.</b></a>
</div></td></tr>
</table>

</div>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-implement"></a><a class="quiet" href="#implement"><b>7</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#implement"><b>Implementing the MCL algorithm</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-faq7.1"></a> <a class="intern" href="#faq7.1"><b>7.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#faq7.1"><b>How easy is it to implement the MCL algorithm?</b></a>
</div></td></tr>
</table>

</div>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-overlap"></a><a class="quiet" href="#overlap"><b>8</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#overlap"><b>Cluster overlap / MCL iterand cluster interpretation</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-olapintro"></a> <a class="intern" href="#olapintro"><b>8.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#olapintro"><b>Introduction</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-ccco"></a> <a class="intern" href="#ccco"><b>8.2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#ccco"><b>Can the clusterings returned by mcl contain overlap?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-imac"></a> <a class="intern" href="#imac"><b>8.3</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#imac"><b>How do I obtain the clusterings associated with MCL iterands?</b></a>
</div></td></tr>
</table>

</div>
<hr>
<div style="margin-top:0em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="toc-misc"></a><a class="quiet" href="#misc"><b>9</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="quiet" href="#misc"><b>Miscellaneous</b></a>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr>
<tr><td width=32 valign="top" class=right><a name="toc-defaults"></a> <a class="intern" href="#defaults"><b>9.1</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#defaults"><b>How do I find the default settings of mcl?</b></a>
</div></td></tr><tr><td width=32 valign="top" class=right><a name="toc-next"></a> <a class="intern" href="#next"><b>9.2</b></a></td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#next"><b>What's next?</b></a>
</div></td></tr>
</table>

</div>
<br><br>

<a name="faq"></a>
<h2>FAQ</h2>

<div align=center>
<h3><a name="general"></a><a class="quiet" href="#toc-general">1</a><br>General questions
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="faq1.1"></a> <a class="quiet" href="#toc-general">1.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>For whom is mcl and for whom is this FAQ?</b><p class="default L50">
For everybody with an appetite for graph clustering.
Regarding the FAQ, I have kept the amount of
mathematics as low as possible, as far as matrix analysis is concerned.
Inevitably, some terminology pops up and some references are made to the
innards of the MCL algorithm, especially in the section on resources and
accuracy. Graph terminology is used somewhat more carelessly though. The
future might bring definition entries, right now you have to do without.
Mathematically inclined people may be interested in the pointers found in
the <a class="intern" href="#references">REFERENCES</a> section.
<p class="default L50">
Given this mention of mathematics, let me point out this one time only that
using <b>mcl</b> is extremely straightforward anyway. You need only mcl and an
input graph (refer to the <a class="local" href="mcl.html">mcl manual page</a>), and many people
trained in something else than mathematics are using mcl happily.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="overview"></a> <a class="quiet" href="#toc-general">1.2</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What is the relationship between the MCL process, the MCL algorithm, and the 'mcl' implementation?</b><p class="default L50">
<b>mcl</b> is what you use for clustering. It implements the MCL algorithm,
which is a cluster algorithm for graphs. The MCL algorithm is basically
a shell in which the MCL process is computed and interpreted. I will
describe them in the natural, reverse, order.
<p class="default L50">
The MCL process generates a row of stochastic matrices given some initial
stochastic matrix. The elements with even index are obtained by
<i>expanding</i> the previous element, and the elements with odd index are
obtained by <i>inflating</i> the previous element given some inflation
constant. Expansion is nothing but normal matrix squaring, and inflation is
a particular way of rescaling the entries of a stochastic matrix such that
it remains stochastic.
<p class="default L50">
The row of MCL elements (from the MCL process) is in principle without end,
but what happens is that the elements converge to some specific kind of
matrix, called the <i>limit</i> of the process. The heuristic underlying MCL
predicts that the interaction of expansion with inflation will lead to a
limit exhibiting cluster structure in the graph associated with the
initial matrix. This is indeed the case, and several mathematical results
tie MCL iterands and limits and the MCL interpretation together
(<a class="intern" href="#references">REFERENCES</a>).
<p class="default L50">
The MCL algorithm is simply a shell around the MCL process in which
an input graph is transformed into an initial matrix suitable for
starting the process, in which inflation parameters are set, and
in which the MCL process is stopped once the limit is reached,
and in which the result is interpreted as a clustering.
<p class="default L50">
The <b>mcl</b> implementation supplies the functionality of the MCL algorithm,
with some extra facilities for manipulation of the input graph, interpreting
the result, manipulating resources while computing the process, and
monitoring the state of these manipulations.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq1.3"></a> <a class="quiet" href="#toc-general">1.3</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What do the letters MCL stand for?</b><p class="default L50">
For <i>Markov Cluster</i>. The MCL algorithm is a <b>cluster</b> algorithm
that is basically a shell in which an algebraic process is computed.
This process iteratively generates stochastic matrices, also known
as <b>Markov</b> matrices, named after the famous Russian
mathematician Andrei Markov.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq1.4"></a> <a class="quiet" href="#toc-general">1.4</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How could you be so feebleminded to use MCL as abbreviation? Why
is it labeled 'Markov cluster' anyway?</b><p class="default L50">
Sigh. It is a widely known fact that a TLA or Three-Letter-Acronym
is <i>the canonical self-describing abbreviation for the name
of a species with which computing terminology is infested</i> (quoted
from the Free Online Dictionary of Computing). Back when I was
thinking of a nice tag for this cute algorithm, I was
totally unaware of this. I naturally dismissed <i>MC</i>
(and would still do that today). Then <i>MCL</i> occurred
to me, and without giving it much thought I started using it.
A Google search (or was I still using Alta-Vista back then?)
might have kept me from going astray.
<p class="default L50">
Indeed, <i>MCL</i> is used as a tag for <i>Macintosh Common Lisp</i>,
<i>Mission Critical Linux</i>, <i>Monte Carlo Localization</i>, <i>MUD Client
for Linux</i>, <i>Movement for Canadian Literacy</i>, and a gazillion other
things - refer to the file <a class="extern" href="mclmcl.txt">mclmcl.txt</a>. Confusing. It seems that
the three characters <tt>MCL</tt> possess otherworldly magical powers making
them an ever so strange and strong attractor in the space of TLAs. It
probably helps that Em-See-Ell (Em-Say-Ell in Dutch) has some rhythm
to it as well. Anyway MCL stuck, and it's here to stay.
<p class="default L50">
On a more general level, the label <i>Markov Cluster</i> is not an entirely
fortunate choice either. Although phrased in the language of stochastic
matrices, MCL theory bears very little relation to Markov theory, and is
much closer to matrix analysis (including Hilbert's distance) and the theory
of dynamical systems. No results have been derived in the latter framework,
but many conjectures are naturally posed in the language of dynamical
systems.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="innards"></a> <a class="quiet" href="#toc-general">1.5</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Where can I learn about the innards of the MCL algorithm/process?</b><p class="default L50">
Currently, the most basic explanation of the MCL algorithm is found in the
technical report <a class="intern" href="#cafg">[2]</a>. It contains sections on several other
(related) subjects though, and it assumes some working knowledge on graphs,
matrix arithmetic, and stochastic matrices.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq1.6"></a> <a class="quiet" href="#toc-general">1.6</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>For which platforms is mcl available?</b><p class="default L50">
It should compile and run on virtually any flavour of UNIX (including Linux
and the BSD variants of course). Following the instructions in the INSTALL
file shipped with mcl should be straightforward and sufficient. Courtesy to
Joost van Baal who completely autofooled <b>mcl</b>.
<p class="default L50">
Building MCL on Wintel (Windows on Intel chip) should be straightforward if
you use the full suite of cygwin tools. Install cygwin if you do not have it
yet. In the cygwin shell, unpack mcl and simply issue the commands
<i>./configure, make, make install</i>, i.e. follow the instructions in
INSTALL.
<p class="default L50">
This MCL implementation has not yet been reported to run on MAC. For the
latest Mac OS X one would expect that it is certainly possible to
make this happen.
<p class="default L50">
If you have further questions or news about this issue, contact
mcl-devel &lt;at&gt; lists &lt;dot&gt; micans &lt;dot&gt; org.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="versioning"></a> <a class="quiet" href="#toc-general">1.7</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How does mcl's versioning scheme work?</b><p class="default L50">
The current setup, which I hope to continue, is this. All releases are
identified by a date stamp. For example 02-095 denotes day 95 in the year
2002. This date stamp agrees (as of April 2000) with the (differently
presented) date stamp used in all manual pages shipped with that release.
For example, the date stamp of the FAQ you are reading is <b>27 Oct 2005</b>,
which corresponds with the MCL stamp <b>05-300</b>.
The Changelog file contains a list of what's changed/added with each
release. Currently, the date stamp is the primary way of identifying an <b>mcl</b>
release. When asked for its version by using <b>--version</b>, mcl
outputs both the date stamp and a version tag (see below).
<p class="default L50">
In early 2002 it occurred to me that <b>mcl</b> should, in addition to time
stamps, also have something like version numbers, wanting to use those to
indicate noteworthy changes. The April 2002 release got version tag 1.001,
in order to celebrate the then-recent addition of this FAQ, mcl's new
logging facility <b>--log</b>, and <b>clmimac</b> to the MCL distribution. The
January 2003 release had its version number bumped to 1.002, marking MCL's
ability to directly deal with a much more general type of graph encoding.
Currently, the version tag is not used in the mcl distribution name - only
the date stamp is used for that.
</div></td></tr>
</table>

</div>

<div align=center>
<h3><a name="ioformat"></a><a class="quiet" href="#toc-ioformat">2</a><br>Input format
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="faq2.1"></a> <a class="quiet" href="#toc-ioformat">2.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How can I get my data into the MCL matrix format?</b><p class="default L50">
<p class="default L50" style="margin-top:0em; margin-bottom:0em"><b>NOTE</b><br>The program <a class="local" href="mcxdeblast.html">mcxdeblast</a> referenced below is only
available if mcl was configured with --enable-blast.
</p>
<p class="default L50" style="margin-bottom:0">
One of the easiest ways is if you have a list of label pairs with
similarities attached to the pairs.
Put this information into a file with each
pair of labels and the associated similarity on a single line
separated by whitespace. Example:</p>
<pre>apples    oranges    2.14
oranges   pears      0.78
oranges   apples     1.57
pears     apples     1.01</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Suppose the file is called <tt>mydata</tt>.
The following converts your data to MCL format.
</p>
<pre>   mcxdeblast --abc mydata             # create mydata.hdr, mydata.raw
   mcxassemble -b mydata -r max --map  # create mydata.sym</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
<a class="local" href="mcxdeblast.html">mcxdeblast</a> first converts your label input to numerical identifiers
and stores it in a so called <i>raw</i> format.
<a class="local" href="mcxassemble.html">mcxassemble</a> then converts the raw format to MCL format, and it
makes sure that the result is symmetric. The result is stored
in the file <tt>mydata.sym</tt>. It should look like this:</p>
<pre>(mclheader
mcltype matrix
dimensions 3x3
)
(mclmatrix
begin
0 1:0.7800 2:2.1400 $
1 0:0.7800 2:1.0100 $
2 0:2.1400 1:1.0100 $
)</pre>
<p class="default L50" style="margin-bottom:0">
The <b>-r</b>&nbsp;<b>max</b> option causes repeated entries (i.e. the same
label pair specified more than once) to be collapsed by taking
the maximum value. Another option is to add them by using
<b>-r</b>&nbsp;<b>add</b>.
The <b>--map</b> option tells <a class="local" href="mcxassemble.html">mcxassemble</a>
to look for a file <tt>mydata.map</tt> that relates the tab file to
the raw format. This file is also created by <a class="local" href="mcxdeblast.html">mcxdeblast</a>.
<b>Do not forget to use</b> <b>--map</b>!
Refer to <a class="local" href="mcxassemble.html">mcxassemble</a> for more information on these and other
options.
</p>
<p class="default L50" style="margin-bottom:0">
By default <b>mcxdeblast</b> creates a tab file ordered by occurrence
of labels in the input file (<tt>mydata</tt> in this cases).
This can be changed by supplying it with <b>--sort=a</b>
which triggers alphabetic sorting.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq2.2"></a> <a class="quiet" href="#toc-ioformat">2.2</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Can I get my graph into MCL format by directly streaming it?</b><p class="default L50">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
For large graphs it becomes inconvenient to have to go via intermediate
formats, as it can take a substantial amount of time. The problem is
that currently MCL insists on knowing the domains of a matrix before
it will load the matrix itself, but often parsers or loaders
that stream from a file or database cannot supply this information
in time.
Directly streaming a matrix into MCL
requires an adaptive-loading mechanism. This is not yet implemented but it
is high on the TODO list. Adaptive loading will only be supported for
canonical domains (cf <a class="local" href="mcxio.html">mcxio</a>).
</p>
</div></td></tr>
</table>

</div>

<div align=center>
<h3><a name="kind"></a><a class="quiet" href="#toc-kind">3</a><br>What kind of graphs
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="faq3.1"></a> <a class="quiet" href="#toc-kind">3.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What is legal input for MCL?</b><p class="default L50">
Any graph (encoded as a matrix of similarities) that is nonnegative,
i.e. all similarities are greater than or equal to zero.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq3.2"></a> <a class="quiet" href="#toc-kind">3.2</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What is sensible input for MCL?</b><p class="default L50">
It is ok for graphs to be weighted, and they should preferably be symmetric.
They should certainly not contain parts that are (almost) cyclic,
although nothing stops you from experimenting with such input.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq3.3"></a> <a class="quiet" href="#toc-kind">3.3</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Does MCL work for weighted graphs?</b><p class="default L50">
Yes, unequivocally. They should preferably be symmetric/undirected though.
See entries&nbsp;<a class="intern" href="#whatkind">3.7</a> and&nbsp;<a class="intern" href="#goodinput">3.8</a>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq3.4"></a> <a class="quiet" href="#toc-kind">3.4</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Does MCL work for directed graphs?</b><p class="default L50">
Maybe, with a big caveat. See entries&nbsp;<a class="intern" href="#goodinput">3.8</a>
and&nbsp;<a class="intern" href="#directedinput">3.9</a>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq3.5"></a> <a class="quiet" href="#toc-kind">3.5</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Can MCL work for lattices / directed acyclic graphs / DAGs?</b><p class="default L50">
Such graphs [term] can surely exhibit clear cluster structure. If they
do, there is only one way for mcl to find out. You have to change all arcs
to edges, i.e. if there is an arc from i to j with similarity s(i,j) - by
the DAG property this implies s(j,i) = 0 - then make s(j,i) equal to
s(i,j).
<p class="default L50">
This may feel like throwing away valuable information, but in truth the
information that is thrown away (direction) is <i>not</i> informative with
respect to the presence of cluster structure. This may well deserve a longer
discussion than would be justified here.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq3.6"></a> <a class="quiet" href="#toc-kind">3.6</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Does MCL work for tree graphs?</b><p class="default L50">
Nah, I don't think so. More info at entry&nbsp;<a class="intern" href="#whatkind">3.7</a>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="whatkind"></a> <a class="quiet" href="#toc-kind">3.7</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>For what kind of graphs does MCL work well and for which does it not?</b><p class="default L50">
Graphs in which the diameter [term] of (subgraphs induced by) natural
clusters is not too large. Additionally, graphs should preferably be
(almost) undirected (see entry below) and not so sparse that the cardinality
of the edge set is close to the number of nodes.
<p class="default L50">
A class of such very sparse graphs is that of tree graphs. You might look
into <i>graph visualization</i> software and research if you are interested
in decomposing trees into 'tight' subtrees.
<p class="default L50">
The diameter criterion could be violated by
neighbourhood graphs derived from vector data. In the specific case
of 2 and 3 dimensional data, you might be interested
in <i>image segmentation</i> and <i>boundary detection</i>, and for
the general case there is a host of other algorithms out there. [add]
<p class="default L50">
In case of weighted graphs, the notion of <i>diameter</i> is sometimes not
applicable. Generalizing this notion requires inspecting the <i>mixing
properties</i> of a subgraph induced by a natural cluster in terms of its
spectrum. However, the diameter statement is something grounded on heuristic
considerations (confirmed by practical evidence <a class="intern" href="#pcfgcmce">[4]</a>)
to begin with, so you should probably forget about mixing properties.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="goodinput"></a> <a class="quiet" href="#toc-kind">3.8</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What makes a good input graph?
How do I construct the similarities?
How to make them satisfy this Markov condition?</b><p class="default L50">
To begin with the last one: you <i>need not and must not</i> make the
input graph such that it is stochastic aka Markovian [term]. What you
need to do is make a graph that is preferably symmetric/undirected,
i.e. where s(i,j) = s(j,i) for all nodes i and j. It need not be
perfectly undirected, see the following faq for a discussion of that.
<b>mcl</b> will work with the graph of random walks that is associated
with your input graph, and that is the natural state of affairs.
<p class="default L50">
The input graph should preferably be honest in the sense that if s(x,y)=N
and s(x,z)=200N (i.e. the similarities differ by a factor 200), then
this should really reflect that the similarity of y to x is neglectible
compared with the similarity of z to x.
<p class="default L50">
For the rest, anything goes. Try to get a feeling by experimenting.
Sometimes it is a good idea to filter out high-frequency
and/or low-frequency data, i.e. nodes with either very many neighbours
or extremely few neighbours.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="directedinput"></a> <a class="quiet" href="#toc-kind">3.9</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>My input graph is directed. Is that bad?</b><p class="default L50">
It depends. The class of directed graphs can be viewed as a spectrum going
from undirected graphs to uni-directed graphs. <i>Uni-directed</i> is
terminology I am inventing here, which I define as the property that
for all node pairs i, j, at least one of s(i,j) or s(j,i) is zero. In other
words, if there is an arc going from i to j in a uni-directed graph, then
there is no arc going from j to i. I call a node pair i, j,
<i>almost uni-directed</i> if s(i,j) &lt;&lt; s(j,i) or vice versa,
i.e. if the similarities differ by an order of magnitude.
<p class="default L50">
If a graph does not have (large) subparts that are (almost) uni-directed,
have a go with mcl. Otherwise, try to make your graph less uni-directed.
You are in charge, so do anything with your graph as you see fit,
but preferably abstain from feeding mcl uni-directed graphs.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq3.10"></a> <a class="quiet" href="#toc-kind">3.10</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Why does mcl like undirected graphs and why does it
dislike uni-directed graphs so much?</b><p class="default L50">
Mathematically, the mcl iterands will be <i>nice</i> when the input graph is
symmetric, where <i>nice</i> is in this case <i>diagonally symmetric to a
semi-positive definite matrix</i> (ignore as needed). For one thing, such nice
matrices can be interpreted as clusterings in a way that generalizes the
interpretation of the mcl limit as a clustering (if you are curious to these
intermediate clusterings, see <a class="intern" href="#imac">faq entry&nbsp;8.3</a>).
See the <a class="intern" href="#references">REFERENCES</a> section for pointers to mathematical
publications.
<p class="default L50">
The reason that mcl dislikes uni-directed graphs is not very mcl specific,
it has more to do with the clustering problem itself.
Somehow, directionality thwarts the notion of cluster structure.
[add].
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="checksymmetry"></a> <a class="quiet" href="#toc-kind">3.11</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How do I check that my graph/matrix is symmetric/undirected?</b><p class="default L50">
Whether your graph is created by third-party software (e.g. the TribeMCL
module (maintained by Anton Enright)) or by custom sofware written
by someone you know (e.g. yourself), it is advisable to test whether
the software generates symmetric matrices. This can be done as follows
using the <a class="local" href="mcx.html">mcx utility</a>, assuming that you want to test the
matrix stored in file <tt>matrix.mci</tt>. The mcx utility should be available
on your system if mcl was installed in the normal way.
<pre>mcx /matrix.mci lm tp -1 mul add /check wm</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
This loads the graph/matrix stored in <tt>matrix.mci</tt> into <b>mcx</b>'s memory with
the mcx <i>lm</i> primitive. - the leading slash is how strings are
introduced in the stack language interpreted by <b>mcx</b>. The transpose of
that matrix is then pushed on the stack with the <i>tp</i> primitive and
multiplied by minus one. The two matrices are added, and the result is
written to the file <tt>check</tt>.
The transposed matrix is the mirrored version of the original matrix stored
in <tt>matrix.mci</tt>. If a graph/matrix is undirected/symmetric, the mirrored
image is necessarily the same, so if you subtract one from the other it
should yield an all zero matrix.
<p class="default L50">
Thus, the file <tt>check</tt> <i>should look like this</i>:
<pre>(mclheader
mcltype matrix
dimensions &lt;num&gt;x&lt;num&gt;
)
(mclmatrix
begin
)</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Where <tt>&lt;num&gt;</tt> is the same as in the file <tt>matrix.mci</tt>. If this is not
the case, find out what's prohibiting you from feeding mcl symmetric
matrices. Note that any nonzero entries found in the matrix stored as
<tt>check</tt> correspond to node pairs for which the arcs in the two possible
directions have different weight.
</div></td></tr>
</table>

</div>

<div align=center>
<h3><a name="speed"></a><a class="quiet" href="#toc-speed">4</a><br>Speed and complexity
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="howfast"></a> <a class="quiet" href="#toc-speed">4.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How fast is mcl/MCL?</b><p class="default L50">
It's fast - here is how and why. Let N be the number of nodes in the input
graph. A straigtforward implementation of MCL will have time and space
complexity respecively O(N^3) (i.e. cubic in N) and O(N^2) (quadratic in N).
So you don't want one of those.
<p class="default L50">
<b>mcl</b> implements a slightly perturbed version of the MCL process,
as discussed in section <a class="intern" href="#resource">Resource tuning / accuracy</a>.
Refer to that section for a more extensive discussion of all
the aspects involved. This section is only concerned with the high-level
view of things <i>and</i> the nitty gritty complexity details.
<p class="default L50">
While computing the square of a matrix
(the product of that matrix with itself), mcl keeps the matrix sparse
by allowing a certain maximum number of nonzero entries
per stochastic column. The maximum is one of the mcl parameters, and
it is typically set somewhere between 500 and 1000.
Call the maximum K.
<p class="default L50">
mcl's time complexity is governed by the complexity of matrix squaring.
There are two sub-algorithms to consider. The first is the
algorithm responsible for assembling a new vector during matrix
multiplication. This algorithm has worst case complexity O(K^2). The
pruning algorithm (which uses heap selection) has worst case complexity
O(L*log(K)), where L is how large a newly computed matrix column can get
before it is reduced to at most K entries. L is <i>bound by</i> the smallest
of the two numbers N and K^2 (the square of K), but on average
L will be much smaller than that, as the presence of cluster structure aids in
keeping the factor L low. [Related to this is the fact that clustering
algorithms are actually used to compute matrix splittings that minimize
the number of cross-computations when carrying out matrix
multiplication among multiple processors.]
In actual cases of heavy usage, L is of order in the tens of thousands, and
K is in the order of several hundreds up to a thousand.
<p class="default L50">
It is safe to say that in general the worst case complexity of mcl
is of order O(N*K^2); for extremely tight and dense graphs this
might become O(N*N*log(K)). Still, these are worst case estimates,
and observed running times for actual usage are much better than that.
(refer to faq&nbsp;<a class="intern" href="#stats">4.2</a>).
<p class="default L50">
In this analysis, the number of iterations required by mcl was not
included. It is nearly always far below 100. Only the first
few iterations are genuinely time consuming; the first few iterations
(some number below 10) are usually responsible for more than 95 percent
of the running time.
<p class="default L50">
The process of removing the smallest entries of a vector is called
pruning. mcl provides extensive facilities for monitoring and controlling
the effect of pruning, and it will output statistics and a summary once it
is done. More information is provided in the pruning section of the
<a class="local" href="mcl.html">mcl manual</a> and <a class="intern" href="#resource">Section&nbsp;5</a>
in this FAQ.
<p class="default L50">
The space complexity is of order O(N*K).
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="stats"></a> <a class="quiet" href="#toc-speed">4.2</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What statistics are available?</b><p class="default L50">
Few. Some experiments are described in <a class="intern" href="#pcfgcmce">[4]</a>, and
<a class="intern" href="#eaflsdopf">[5]</a> mentions large graphs being clustered in very reasonable
time. In protein clustering, <b>mcl</b> has been applied to graphs with up to one
million nodes, and on high-end hardware such graphs can be clustered within
a few hours.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="colsort"></a> <a class="quiet" href="#toc-speed">4.3</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Does this implementation need to sort vectors?</b><p class="default L50">
No, it does not. You might expect that one needs to sort
a vector in order to obtain the K largest entries, but a simpler
mechanism called <i>heap selection</i> does the job nicely.
Selecting the K largest entries from a set of L by sorting
would require O(L*log(L)) operations; heap selection
requires O(L*log(K)) operations.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="approx"></a> <a class="quiet" href="#toc-speed">4.4</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>mcl does not compute the ideal MCL process!</b><p class="default L50">
Indeed it does not. What are the ramifications? Several entries in section
<a class="intern" href="#resource">Resource tuning / accuracy</a> discuss this issue. For a synopsis,
consider two ends of a spectrum.
<p class="default L50">
On the one end, a graph that has very strong cluster structure,
with clearly (and not necessarity fully) separated clusters. This
mcl implementation will certainly retrieve those clusters if the
graphs falls into <a class="intern" href="#whatkind">the category of graphs</a> for which
mcl is applicable.
On the other end, consider a graph that has only weak cluster
structure superimposed on a background of a more or less random
graph. There might sooner be a difference between the clustering
that should ideally result and the one computed by mcl. Such
a graph will have a large number of whimsical nodes that might end up
either here or there, nodes that are of a peripheral nature,
and for which the (cluster) destination is very sensitive to
fluctutations in edge weights or algorithm parametrizations (any
algorithm, not just mcl).
<p class="default L50">
One can
say that the perturbation effect of the pruning process applied by
mcl is just a small source of noise. Additionally, graphs at the noisy
end of the spectrum will generally be very susceptible to changes in
parametrization of the MCL algorithm and process, and the perturbation
caused by computing an imperfect process will generally be small
compared with the effect of changing parametrizations.
<p class="default L50">
Of course, there is the issue of very large and very dense graphs.
The act of pruning will have a larger impact as graphs grow
larger and denser.
Obviously, mcl will have trouble dealing with such very large and very dense
graphs - so will other methods.
<p class="default L50">
Finally, there is the engineering approach, which offers the possibility of
pruning a whole lot of speculation. Do the experiments with <b>mcl</b>, try it
out, and see what's there to like and dislike.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="elsewhere"></a> <a class="quiet" href="#toc-speed">4.5</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>I've read elsewhere that MCL is slow [compared with XYZ]</b><p class="default L50">
Presumably, they did not know mcl, and did not read the parts
in <a class="intern" href="#gcbfs">[1]</a> and <a class="intern" href="#cafg">[2]</a> that discuss implementation. Perhaps
they assume or insist that the only way to implement MCL is to implement the
ideal process. And there is always the genuine possibility
of a <i>really</i> stupifyingly fast algorithm.
[One such publication is Ulrik Brandes, Marco Gaertler, and
Dorothea Wagner: Experiments on Graph Clustering Algorithms. Proc. 11th
Europ. Symp. Algorithms (ESA '03), Springer LNCS].
</div></td></tr>
</table>

</div>

<div align=center>
<h3><a name="resource"></a><a class="quiet" href="#toc-resource">5</a><br>Resource tuning / accuracy
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="wdymbrt"></a> <a class="quiet" href="#toc-resource">5.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What do you mean by resource tuning?</b><p class="default L50">
<b>mcl</b> computes a process in which stochastic matrices are alternately
expanded and inflated. Expansion is nothing but standard matrix
multiplication, inflation is a particular way of rescaling the matrix
entries.
<p class="default L50">
Expansion causes problems in terms of both time and space. mcl works with
matrices of dimension N, where N is the number of nodes in the input graph.
If no precautions are taken, the number of entries in the mcl iterands
(which are stochastic matrices) will soon approach the square of N. The
time it takes to compute such a matrix will be proportional to the cube of
N. If your input graph has 100.000 nodes, the memory requirements become
infeasible and the time requirements become impossible.
<p class="default L50">
What mcl does is perturbing the process it computes a little
by removing the smallest entries - it keeps its matrices <i>sparse</i>.
This is a natural thing to do, because the matrices are sparse in
a weighted sense (a very high proportion of the stochastic mass
is contained in relatively few entries), and the process converges
to matrices that are extremely sparse, with usually no more than N entries.
It is thus known that the MCL iterands are sparse in a weighted
sense and are usually very close to truly sparse matrices.
The way mcl perturbs its matrices is by the strategy
of pruning, selection, and recovery that is extensively described
in the <a class="local" href="mcl.html">mcl manual page</a>.
The question then is: What is the effect of this perturbation
on the resulting clustering, i.e. how would the clustering
resulting from a <i>perfectly computed</i> mcl process compare with
the clustering I have on disk?
<a class="intern" href="#pcmp">Faq entry&nbsp;5.3</a> discusses this issue.
<p class="default L50">
The amount of <i>resources</i> used by mcl is bounded in terms of the maximum
number of neighbours a node is allowed to have during all computations.
Equivalently, this is the maximum number of nonzero entries a matrix column
can possibly have. This number, finally, is the maximum of the
the values corresponding with the <b>-S</b> and <b>-R</b> options.
The latter two are listed when using the <b>-z</b> option
(see faq&nbsp;<a class="intern" href="#defaults">9.1</a>).
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq5.2"></a> <a class="quiet" href="#toc-resource">5.2</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How do I compute the maximum amount of RAM needed by mcl?</b><p class="default L50">
It is rougly equal to
<pre>2 * s * K * N</pre>
bytes, where 2 is the number of matrices held in memory by <b>mcl</b>, s is the
size of a single cell (c.q. matrix entry or node/arc specification), N is
the number of nodes in the input graph, and where K is the maximum of the
values corresponding with the <b>-S</b> and <b>-R</b> options (and this
assumes that the average node degree in the input graph does not exceed K
either). The value of s can be found by using the <b>-z</b> option. It
is listed in one of the first lines of the resulting output. s equals the
size of an int plus the size of a float, which will be 8 on most systems.
The estimate above will in most cases be way too pessimistic (meaning
you do not need that amount of memory).
<p class="default L50">
The <b>-how-much-ram</b> option is provided by mcl for computing
the bound given above. This options takes as argument the number of
nodes in the input graph.
<p class="default L50">
The theoretically more precise upper bound is slightly larger due to
overhead. It is something like
<pre>( 2 * s * (K + c)) * N</pre>
where c is 5 or so, but one should not pay attention to such a small
difference anyway.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="pcmp"></a> <a class="quiet" href="#toc-resource">5.3</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How much does the mcl clustering differ from the clustering resulting
from a perfectly computed MCL process?</b><p class="default L50">
For graphs with up until a few thousand nodes a <i>perfectly computed</i>
MCL process can be achieved by abstaining from pruning and doing
full-blown matrix arithmetic. Of course, this still leaves the
issue of machine precision, but let us wholeheartedly ignore that.
<p class="default L50">
Such experiments give evidence (albeit incidental) that pruning is indeed
really what it is thought to be - a small perturbation. In many cases, the
'approximated' clustering is identical to the 'exact' clustering. In other
cases, they are very close to each other in terms of the metric
split/join distance as computed by <a class="local" href="clmdist.html">clmdist</a>.
Some experiments with randomly generated test graphs, clustering,
and pruning are described in <a class="intern" href="#pcfgcmce">[4]</a>.
<p class="default L50">
On a different level of abstraction, note that perturbations of the
inflation parameter will also lead to perturbations in the resulting
clusterings, and surely, large changes in the inflation parameter will in
general lead to large shifts in the clusterings. Node/cluster pairs that
are different for the approximated and the exact clustering will very
likely correspond with nodes that are in a boundary region between two or
more clusters anyway, as the perturbation is not likely to move a node from
one core of attraction to another.
<p class="default L50">
<a class="intern" href="#qsep">Faq entry 5.6</a> has more to say about this subject.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="enoughresources"></a> <a class="quiet" href="#toc-resource">5.4</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How do I know that I am using enough resources?</b><p class="default L50">
In <b>mcl</b> parlance, this becomes <i>how do I know that my</i> <b>-scheme</b>
<i>parameter is high enough</i> or more elaborately <i>how do I know
that the values of the {-P, -S, -R, -pct} combo are high enough?</i>
<p class="default L50">
There are several aspects. First, watch the <i>jury marks</i> reported by <b>mcl</b>
when it's done.
The jury marks are three grades, each out of 100. They indicate how well
pruning went. If the marks are in the seventies, eighties, or nineties, mcl
is probably doing fine. If they are in the eighties or lower, try to see if
you can get the marks higher by spending more resources (e.g. increase the
parameter to the <b>-scheme</b> option).
<p class="default L50">
Second, you can do multiple <b>mcl</b> runs for different resource schemes,
and compare the resulting clusterings using <a class="local" href="clmdist.html">clmdist</a>. See
the <a class="local" href="clmdist.html">clmdist manual</a> for a case study.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="nmap"></a> <a class="quiet" href="#toc-resource">5.5</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Where is the mathematical analysis of this mcl pruning strategy?</b><p class="default L50">
There is none. [add]
<p class="default L50">
Ok, the next entry gives an engineer's rule of thumb.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="qsep"></a> <a class="quiet" href="#toc-resource">5.6</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What qualitative statements can be made about the effect of pruning?</b><p class="default L50">
The more severe pruning is, the more the computed process will tend to
converge prematurely. This will generally lead to finer-grained clusterings.
In cases where pruning was severe, the <b>mcl</b> clustering will likely be closer
to a clustering ideally resulting from another MCL process with higher
inflation value, than to the clustering ideally resulting from the same MCL
process. Strong support for this is found in a general observation
illustrated by the following example. Suppose u is a stochastic vector
resulting from expansion:
<pre>u   =  0.300 0.200 0.200 0.100 0.050 0.050 0.050 0.050</pre>
Applying inflation with inflation value 2.0 to u gives
<pre>v   =  0.474 0.211 0.211 0.053 0.013 0.013 0.013 0.013</pre>
Now suppose we first apply pruning to u such that the 3 largest entries
0.300, 0.200 and 0.200 survive,
throwing away 30 percent of the stochastic mass
(which is quite a lot by all means).
We rescale those three entries and obtain
<pre>u'  =  0.429 0.286 0.286 0.000 0.000 0.000 0.000 0.000</pre>
Applying inflation with inflation value 2.0 to u' gives
<pre>v'  =  0.529 0.235 0.235 0.000 0.000 0.000 0.000 0.000</pre>
If we had applied inflation with inflation value 2.5 to u, we would
have obtained
<pre>v'' =  0.531 0.201 0.201 0.038 0.007 0.007 0.007 0.007</pre>
The vectors v' and v'' are much closer to each other
than the vectors v' and v, illustrating the general idea.
<p class="default L50">
In practice, <b>mcl</b> should (on average) do much better than in this
example.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq5.7"></a> <a class="quiet" href="#toc-resource">5.7</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>At different high resource levels my clusterings are not identical.
How can I trust the output clustering?</b><p class="default L50">
Did you read all other entries in this section? That should have
reassured you somewhat, except perhaps for
<a class="intern" href="#nmap">Faq answer&nbsp;5.5</a>.
<p class="default L50">
You need not feel uncomfortable with the clusterings still being different
at high resource levels, if ever so slightly. In all likelihood, there
are anyway nodes which are not in any core of attraction, and that are on
the boundary between two or more clusterings. They may go one way or
another, and these are the nodes which will go different ways even at high
resource levels. Such nodes may be stable in clusterings obtained for
lower inflation values (i.e. coarser clusterings), in which the different
clusters to which they are attracted are merged.
<p class="default L50">
By the way, you do know all about <a class="local" href="clmdist.html">clmdist</a>, don't you? Because the
statement that clusterings are not identical should be quantified: <i>How
much do they differ?</i> This issue is discussed in the <a class="local" href="clmdist.html">clmdist</a> manual
page - clmdist gives you a robust measure for the distance (dissimilarity)
between two clusterings.
<p class="default L50">
There are other means of gaining trust in a clustering, and there are
different issues at play. There is the matter of how accurately this <b>mcl</b>
computed the mcl process, and there is the matter of how well the chosen
inflation parameter fits the data. The first can be judged by looking at
the jury marks (<a class="intern" href="#enoughresources">faq&nbsp;5.4</a>)
and applying clmdist to different clusterings. The
second can be judged by measurement (e.g. use <a class="local" href="clminfo.html">clminfo</a>) and/or
inspection (use your judgment).
</div></td></tr>
</table>

</div>

<div align=center>
<h3><a name="granularity"></a><a class="quiet" href="#toc-granularity">6</a><br>Tuning cluster granularity
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="faq6.1"></a> <a class="quiet" href="#toc-granularity">6.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How do I tune cluster granularity?</b><p class="default L50">
There are several ways for influencing cluster granularity. These ways and
their relative merits are successively discussed below. The
<a class="local" href="clmdist.html">clmdist(1) manual</a> contains an example of doing multiple
mcl runs for finding granularily different clusterings, using the
most common approach, namely that of varying inflation.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq6.2"></a> <a class="quiet" href="#toc-granularity">6.2</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>The effect of inflation on cluster granularity.</b><p class="default L50">
The main handle for changing inflation is the <b>-I</b> option. This is
also <i>the</i> principal handle for regulating cluster granularity. Unless
you are mangling huge graphs it could be the only <b>mcl</b> option you ever need
besides the output redirection option <b>-o</b>.
<p class="default L50">
Increasing the value of <b>-I</b> will increase cluster granularity.
Conceivable values are from 1.1 to 5.0 or so, but the range of suitable
values will certainly depend on your input graph. For many graphs, 1.1 will
be far too low, and for many other graphs, 5.0 will be far too high. You
will have to find the right value or range of values by experimenting, using
your judgment, and using measurement tools such as <a class="local" href="clmdist.html">clmdist</a> and
<a class="local" href="clminfo.html">clminfo</a>. The default 2.0 is a good value to begin the experimental
stage with.
<p class="default L50">
For experiments that are more subtle with respect to inflation,
<b>mcl</b> provides the <b>-i</b> option in conjunction with the <b>-l</b>
(small letter ell) option. Do this only if you have the intention of
playing around with mcl in order to study the characteristics of the
process that it computes, and <i>maybe</i>, just <i>maybe</i>, use it in a
production environment if you find it useful. In the first vein, you may be
interested to know that <a class="local" href="mcx.html">mcx</a> is a stack language/interpreter in which
the entire MCL algorithm can be written in three lines of code. It provides
comprehensive access to the MCL graph and matrix libraries. However, the
<b>mcx</b> interface to the MCL pruning facilities is not yet satisfactory at this
time.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="simil_granul"></a> <a class="quiet" href="#toc-granularity">6.3</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>The effect of similarity distribution homogeneity on cluster granularity.</b><p class="default L50">
How similarities in the input graph were derived, constructed,
adapted, filtered (et cetera) will affect cluster granularity.
It is important that the similarities are honest;
refer to <a class="intern" href="#goodinput">faq&nbsp;3.8</a>.
<p class="default L50">
Another issue is that homogeneous similarities tend to result in more
coarse-grained clusterings. You can make a set of similarities more
homogeneous by applying some function to all of them, e.g. for all pairs of
nodes (x y) replace S(x,y) by the square root, the logarithm, or some other
convex function. Note that you need not worry about scaling, i.e. the
possibly large changes in magnitude of the similarities. MCL is not affected
by absolute magnitudes, it is only affected by magnitudes taken relative to
each other.
<p class="default L50" style="margin-bottom:0"><b>UPDATE</b><br>
As of version 03-154, mcl supports the pre-inflation <b>-pi</b>&nbsp;<i>f</i> option,
where <i>f</i> is the inflation parameter described below.
Use this option rather than the convoluted procedure described below.
Read on to find out what it does.
</p>
<p class="default L50">
Here is how to make a graph more homogeneous with respect to the weight
function. Given <tt>orig.mci</tt>, clustering <tt>revised.mci</tt> as constructed
below should generally lead to coarser clusterings.
<pre>mcx /orig.mci lm 0.5 hdp /revised.mci wm</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
This simply applies inflation with parameter 0.5 to <tt>orig.mci</tt>.
In the <b>mcx</b> language, <b>hdp</b> stands for Hadamard power (entrywise power),
which is equivalent to inflation except that the normalization step is omitted.
This step is not needed since it is part of mcl (initialization) itself.
The parameter 0.5 can be changed to other values in the range <tt>[0..1.0]</tt>.
The closer it is to zero, the more clusterings will tend to be coarse.
<p class="default L50">
If the parameter is chosen larger than 1.0, say in the range <tt>[1.2..5.0]</tt>
then clusterings will tend to be more finer-grained. For example,
<pre>mcx /orig.mci lm 3.0 hdp /revised.mci wm</pre>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq6.4"></a> <a class="quiet" href="#toc-granularity">6.4</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>The effect of initial centering on cluster granularity.</b><p class="default L50">
This refers to the <b>-c</b> parameter, which adds loops to the input
graph. Its default value is 1.0, which results in loops of a somehow
'neutral' weight to be added. If you need to really fine-tune granularity,
this option can be of use, otherwise you should abstain from using it.
Increasing its value will increase cluster granularity.
<p class="default L50">
Conceivable/normal values are in the range 1.0 to 5.0, but nothing
stops you from going higher or slightly lower. Going lower than
0.5 is definitely not a good idea.
<p class="default L50">
If you are into clustering at high levels of granularity, there is the issue
whether to further increase <b>-I</b>, or whether to start increasing or
further increase <b>-c</b>. It will really depend on the characteristics
of the graph you are working with, and at this point in time I cannot even
give advice in terms of a general categorization. Experiment, learn, and let
me know the results if you like.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="faq6.5"></a> <a class="quiet" href="#toc-granularity">6.5</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How to implement two-level approaches using mcl.</b><p class="default L50">
If changing inflation does not yield clusterings that are sufficiently
coarse to your liking, you may consider trying a two-level approach.
Presumably your input graph is very large if you find yourself in this
situation. You should be aware of the possibility that the graph you are
clustering simply does not posses the type of coarse-grained structure that
you are looking for.
<p class="default L50">
Two-level approaches can be implemented in a variety of ways, and you may
wish to invoke tools other than mcl. However, it is possible to experiment
with two-level approaches using <b>mcl</b> and its associated utility <b>mcx</b>. Here
is how, assuming your original graph is called <tt>orig.mci</tt>.
<p class="default L50"><b>Warning</b><br> This approach is a little crude, and will suffer
if (many) small clusters are present.
<pre>mcl orig.mci -I 5.0 -c 3.0 -scheme 5 -o orig.i5.mco</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Cluster it first so that you get a fine-grained clustering.
Since <tt>orig.mci</tt> is likely a large graph, I opted for a high scheme.
<pre>mcx /orig.i5.mco lm tp exch     # line continues
            /orig.mci lm exch mul mul tp add /coarse.mci wm</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
This transforms the clustering+graph into a new graph <tt>coarse.mci</tt> where
the clusters are nodes. You may, upon inspection, wish to change the
homogeneity of the weight distribution by applying the method described in
<a class="intern" href="#simil_granul">faq entry 6.3</a> - but that's
something best left for optionally fine-tuning this method once you decide
it has merits.
<pre>mcl coarse.mci -I 2.0 -c 0.0 -scheme 5 -o coarse.mco</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Cluster the coarsened graph, and keep the loops as computed
in the coarsening step.
<pre>mcx /orig.i5.mco lm /coarse.mco lm mul /projected.mco wm</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Project the 'coarsened' clustering back onto the original graph.
Now <tt>projected.mco</tt> should be a coarse cluster for <tt>orig.mci</tt>.
<p class="default L50">
There are a lot of parameters to play with here; e.g. the 5.0, 3.0 and
2.0, and 1.0. These seem reasonable defaults.
</div></td></tr>
</table>

</div>

<div align=center>
<h3><a name="implement"></a><a class="quiet" href="#toc-implement">7</a><br>Implementing the MCL algorithm
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="faq7.1"></a> <a class="quiet" href="#toc-implement">7.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How easy is it to implement the MCL algorithm?</b><p class="default L50">
Very easy, if you will be doing small graphs only, say up to a few thousand
entries at most. These are the basic ingredients:
<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left>o</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Adding loops to the input graph, conversion to a stochastic matrix.
</div></td></tr><tr><td width=32 valign="top" class=left>o</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Matrix multiplication and matrix inflation.
</div></td></tr><tr><td width=32 valign="top" class=left>o</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
The interpretation function mapping MCL limits onto clusterings.
</div></td></tr>
</table>

</div>
<p class="default L50">
These must be wrapped in a program that does graph input and cluster output,
alternates multiplication (i.e. expansion) and inflation in a loop, monitors
the matrix iterands thus found, quits the loop when convergence is detected,
and interprets the last iterand.
<p class="default L50">
Implementing matrix muliplication is a standard exercise. Implementing
inflation is nearly trivial. The hardest part may actually be the
interpretation function, because you need to cover the corner cases of
overlap and attractor systems of cardinality greater than one.
<p class="default L50">
In Mathematica or Maple, this should be doable in at most 50 lines of code.
For perl you may need 50 more lines - note that MCL does not use intricate
and expensive operations such as matrix inversion or matrix reductions. In
lower level languages such as C a basic MCL program may need a few hundred
lines, but the largest part will probably be input/output and
interpretation.
<p class="default L50">
It is perhaps even such that implementing the basic MCL algorithm makes a
nice programming exercise. However, if you need an implementation that
scales to several hundreds of thousands of nodes and possibly beyond, then
your duties become much heavier. This is because one needs to prune MCL
iterands (c.q. matrices) such that they remain sparse. This must be done
carefully and preferably in such a way that a trade-off between speed,
memory usage, and potential losses or gains in accuracy can be controlled
via monitoring and logging of relevant characteristics.
Some other points are
i) support for threading via pthreads, openMP, or some other parallel
programming API.
ii) a robust and generic interpretation function is written in
terms of weakly connected components.
</div></td></tr>
</table>

</div>

<div align=center>
<h3><a name="overlap"></a><a class="quiet" href="#toc-overlap">8</a><br>Cluster overlap / MCL iterand cluster interpretation
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="olapintro"></a> <a class="quiet" href="#toc-overlap">8.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Introduction</b><p class="default L50">
A natural mapping exists of MCL iterands to DAGs
(directed acyclic graphs). This is because MCL iterands are generally
<i>diagonally positive semi-definite</i> - see <a class="intern" href="#supfg">[3]</a>.
Such a DAG can be interpreted as a clustering, simply by taking
as cores all endnodes (sinks) of the DAG, and by attaching to each
core all the nodes that reach it. This procedure may result
in clusterings containing overlap.
<p class="default L50">
In the MCL limit, the associated DAG has in general a very degenerated
form, which induces overlap only on very rare occasions (see
<a class="intern" href="#ccco">faq entry 8.2</a>).
<p class="default L50">
Interpreting <b>mcl</b> iterands as clusterings may well be interesting.
Few experiments have been done so far. It is clear though that
early iterands generally contain the most overlap (when interpreted
as clusterings). Overlap dissappears soon as the iterand
index increases. For more information, consult the other entries
in this section and the <a class="local" href="clmimac.html">clmimac manual page</a>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="ccco"></a> <a class="quiet" href="#toc-overlap">8.2</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>Can the clusterings returned by mcl contain overlap?</b><p class="default L50">
No. Clusterings resulting from the abstract MCL algorithm may in theory
contain overlap, but the default behaviour in <b>mcl</b> is to remove it should it
occur, by allocating the nodes in overlap to the first cluster in which they
are seen. <b>mcl</b> will warn you if this occurs. This behaviour is switched
off by supplying <b>--keep-overlap=yes</b>.
<p class="default L50">
Do note that overlap is mostly a theoretical possibility.
It is conjectured that it requires the presence of very strong
symmetries in the input graph, to the extent that there <i>exists
an automorphism of the input graph mapping the overlapping part
onto itself</i>.
<p class="default L50">
It is possible to construct (highly symmetric) input graphs leading to
cluster overlap. Examples of overlap in which a few nodes are involved are
easy to construct; examples with many nodes are exceptionally hard to
construct.
<p class="default L50">
Clusterings associated with intermediate/early MCL iterands
may very well contain overlap, see the
<a class="intern" href="#olapintro">introduction in this section</a> and other entries.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="imac"></a> <a class="quiet" href="#toc-overlap">8.3</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How do I obtain the clusterings associated with MCL iterands?</b><p class="default L50">
There are two options. If
you are interested in clusterings containing overlap, you
should go for the second. If not, use the first, but beware
that the resulting clusterings may contain overlap.
<p class="default L50">
The first solution is to use <b>-dump</b>&nbsp;<b>cls</b> (probably in conjunction
with either <b>-L</b> or <b>-dumpi</b> in order to limit the number of
matrices written). This will cause <b>mcl</b> to write the clustering generically
associated with each iterand to file. The <b>-dumpstem</b> option may be
convenient as well.
<p class="default L50">
The second solution is to use the <b>-dump</b>&nbsp;<b>ite</b> option
(<b>-dumpi</b> and <b>-dumpstem</b> may be of use again). This will
cause <b>mcl</b> to write the intermediate iterands to file. After that, you can
apply <b>clmimac</b> (interpret matrix as clustering) to those iterands. <b>clmimac</b>
has a <b>-tight</b> parameter which affects the mapping of matrices to
clusterings. It takes a value between 0 and 100 as argument. The default is
100 and corresponds with the strict mapping. Lowering the <b>-tight</b>
value will generally result in clusterings containing more overlap. This
will have the largest effect for early iterands; its effect will diminish as
the iterand index increases.
<p class="default L50">
When set to 0, the <b>-tight</b> parameter results in the clustering
associated with the DAG associated with an MCL iterand as described
in <a class="intern" href="#supfg">[3]</a>. This DAG is pruned (thus possibly resulting
in less overlap in the clustering) by increasing the <b>-tight</b>
parameter. [add]
</div></td></tr>
</table>

</div>

<div align=center>
<h3><a name="misc"></a><a class="quiet" href="#toc-misc">9</a><br>Miscellaneous
</h3>
</div>

<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=left><a name="defaults"></a> <a class="quiet" href="#toc-misc">9.1</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>How do I find the default settings of mcl?</b><p class="default L50">
Use <b>-z</b> to find out the actual settings - it shows
the settings as resulting from the command line options (e.g. the default
settings if no other options are given).
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td width=32 valign="top" class=left><a name="next"></a> <a class="quiet" href="#toc-misc">9.2</a></td><td width=8>&nbsp;</td><td><div style="text-align:justify"><b>What's next?</b><p class="default L50">
I'd like to port MCL to cluster computing, using one of the
PVM, MPI, or openMP frameworks.
For the 1.002 release, mcl's internals were rewritten to allow more general
matrix computations. Among other things, mcl's data structures and primitive
operations are now more suited to be employed in a distributed computing
environment. However, much remains to be done before mcl can operate
in such an environment.
<p class="default L50">
At some point in the future a second, xml-based, ascii input format
may be introduced.
<p class="default L50">
If you feel that mcl should support some other standard matrix format,
let us know.
</div></td></tr>
</table>

</div>

<a name="bugs"></a>
<h2>BUGS</h2>
<p class="default L50">
This FAQ tries to compromise between being concise and comprehensive. The
collection of answers should preferably cover the universe of questions at a
pleasant level of semantic granularity without too much overlap. It should
offer value to people interested in clustering but without sound
mathematical training. Therefore, if this FAQ has not failed somewhere,
it must have failed.
<p class="default L50">
Send criticism and missing questions for consideration to mcl-faq at
micans.org.

<a name="author"></a>
<h2>AUTHOR</h2>
<p class="default L50">
Stijn van Dongen.

<a name="seealso"></a>
<h2>SEE ALSO</h2>
<p class="default L50">
<a class="local" href="mclfamily.html">mclfamily</a> for an overview of all the documentation
and the utilities in the mcl family.
<p class="default L50">
mcl's home at <a class="extern" href="http://micans.org/mcl/">http://micans.org/mcl/</a>.

<a name="references"></a>
<h2>REFERENCES</h2>
<p class="default L50">
<a name="gcbfs">[1]</a>
Stijn van Dongen. <i>Graph Clustering by Flow Simulation</i>.
PhD thesis, University of Utrecht, May 2000.<br>
<a class="extern" href="http://www.library.uu.nl/digiarchief/dip/diss/1895620/inhoud.htm">http://www.library.uu.nl/digiarchief/dip/diss/1895620/inhoud.htm</a>
<p class="default L50">
<a name="cafg">[2]</a>
Stijn van Dongen. <i>A cluster algorithm for graphs</i>.
Technical Report INS-R0010, National Research Institute for Mathematics and
Computer Science in the Netherlands, Amsterdam, May 2000.<br>
<a class="extern" href="http://www.cwi.nl/ftp/CWIreports/INS/INS-R0010.ps.Z">http://www.cwi.nl/ftp/CWIreports/INS/INS-R0010.ps.Z</a>
<p class="default L50">
<a name="supfg">[3]</a>
Stijn van Dongen. <i>A stochastic uncoupling process for graphs</i>.
Technical Report INS-R0011, National Research Institute for Mathematics and
Computer Science in the Netherlands, Amsterdam, May 2000.<br>
<a class="extern" href="http://www.cwi.nl/ftp/CWIreports/INS/INS-R0011.ps.Z">http://www.cwi.nl/ftp/CWIreports/INS/INS-R0011.ps.Z</a>
<p class="default L50">
<a name="pcfgcmce">[4]</a>
Stijn van Dongen. <i>Performance criteria for graph clustering and Markov
cluster experiments</i>. Technical Report INS-R0012, National Research
Institute for Mathematics and Computer Science in the Netherlands,
Amsterdam, May 2000.<br>
<a class="extern" href="http://www.cwi.nl/ftp/CWIreports/INS/INS-R0012.ps.Z">http://www.cwi.nl/ftp/CWIreports/INS/INS-R0012.ps.Z</a>
<p class="default L50">
<a name="eaflsdopf">[5]</a>
Enright A.J., Van Dongen S., Ouzounis C.A.
<i>An efficient algorithm for large-scale detection of protein families</i>,
Nucleic Acids Research 30(7):1575-1584 (2002).

<a name="notes"></a>
<h2>NOTES</h2>
<p class="default L50">
This page was generated from <b>ZOEM</b> manual macros,
<a class="extern" href="http://micans.org/zoem">http://micans.org/zoem</a>. Both html and roff pages can be created
from the same source without having to bother with all the usual conversion
problems, while keeping some level of sophistication in the typesetting.
<a class="local" href="mclfaq.ps">This</a> is the PostScript derived from the zoem
troff output.
</body>
</html>
