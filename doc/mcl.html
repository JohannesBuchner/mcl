<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<!-- Copyright (c) 2005 Stijn van Dongen -->
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
body {
text-align: justify;
color: #001111;
background: white;
margin-left: 8%;
margin-right: 8%;
font-family: Helvetica, Univers, Verdana, sans-serif;
}
p.default {
font-family: Helvetica, Univers, Verdana, sans-serif;
text-align: justify;
}
p.L53 { font-size: 30pt; }
p.L52 { font-size: 20pt; }
p.L51 { font-size: 15pt; }
p.L50 { font-size: 12pt; }
p.L49 { font-size: 10pt; }
p.L48 { font-size: 9pt; }
p.L47 { font-size: 8pt; }
td {
font-family: Helvetica, Univers, Verdana, sans-serif;
text-align: justify;
}
h3 { margin-top:1em; }
h2 { margin-top:2em; }
.left { text-align: left; align: left; }
.right { text-align: right; align: right; }
.center { text-align: center; align: center; }
a:link { text-decoration: none; }
a:active { text-decoration: none; }
a:visited { text-decoration: none; }
a:link { color: #1111aa; }
a:active { color: #1111aa; }
a:visited { color: #111166; }
a.local:link { color: #11aa11; }
a.local:active { color: #11aa11; }
a.local:visited { color: #116611; }
a.intern:link { color: #1111aa; }
a.intern:active { color: #1111aa; }
a.intern:visited { color: #111166; }
a.extern:link { color: #aa1111; }
a.extern:active { color: #aa1111; }
a.extern:visited { color: #661111; }
a.quiet:link { color: black; }
a.quiet:active { color: black; }
a.quiet:visited { color: black; }
div.copy
{ font-size: 12pt;
font-family: monospace;
text-align: left;
white-space: pre;
margin-left: 2em;
margin-top: 1em;
margin-bottom: 1em;
}
div.indent
{ margin-left: 8%;
margin-right: 0%;
}
</style>
<title>The mcl manual</title>
</head>
<body>
<p style="text-align:right">
17 Nov 2005&nbsp;&nbsp;&nbsp;
<a class="local" href="mcl.ps"><b>mcl</b></a>
1.006, 05-321
</p>
<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=48 valign="top" class=left>1.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#name">NAME</a>
</div></td></tr><tr><td width=48 valign="top" class=left>2.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#started">GETTING STARTED</a>
</div></td></tr><tr><td width=48 valign="top" class=left>3.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#synopsis">SYNOPSIS</a>
</div></td></tr><tr><td width=48 valign="top" class=left>4.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#description">DESCRIPTION</a>
</div></td></tr><tr><td width=48 valign="top" class=left>5.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#options">OPTIONS</a>
</div></td></tr><tr><td width=48 valign="top" class=left>6.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#pruneoptions">PRUNING OPTIONS</a>
</div></td></tr><tr><td width=48 valign="top" class=left>7.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#pipeline">PIPELINES</a>
</div></td></tr><tr><td width=48 valign="top" class=left>8.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#examples">EXAMPLES</a>
</div></td></tr><tr><td width=48 valign="top" class=left>9.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#applicability">APPLICABILITY</a>
</div></td></tr><tr><td width=48 valign="top" class=left>10.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#files">FILES</a>
</div></td></tr><tr><td width=48 valign="top" class=left>11.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#environment">ENVIRONMENT</a>
</div></td></tr><tr><td width=48 valign="top" class=left>12.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#diagnostics">DIAGNOSTICS</a>
</div></td></tr><tr><td width=48 valign="top" class=left>13.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#bugs">BUGS</a>
</div></td></tr><tr><td width=48 valign="top" class=left>14.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#author">AUTHOR</a>
</div></td></tr><tr><td width=48 valign="top" class=left>15.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#history">HISTORY/CREDITS</a>
</div></td></tr><tr><td width=48 valign="top" class=left>16.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#seealso">SEE ALSO</a>
</div></td></tr><tr><td width=48 valign="top" class=left>17.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#references">REFERENCES</a>
</div></td></tr><tr><td width=48 valign="top" class=left>18.</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<a class="intern" href="#notes">NOTES</a>
</div></td></tr>
</table>

</div>

<a name="name"></a>
<h2>NAME</h2>
<p class="default L50" style="margin-bottom:0">
mcl - The Markov Cluster Algorithm, aka the MCL algorithm.</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> is a cluster algorithm for graphs. A single option controls the
granularity of the output clustering. This is the <a class="intern" href="#opt-I"><b>-I</b>&nbsp;<i>inflation</i></a>
option, described further below.</p>

<a name="started"></a>
<h2>GETTING STARTED</h2>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">There are two main modes of invocation. The most accessible is
<i>label mode</i>
that assumes label input. The input is then a file or stream in which each
line encodes an edge in terms of two labels and a numerical value, separated
by white space. The most basic example of usage is this:</p>
<pre>   <b>mcl</b> &lt;-|fname&gt; <a class="intern" href="#opt--abc"><b>--abc</b></a> <a class="intern" href="#opt-o"><b>-o</b>&nbsp;<i>fname-out</i></a></pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
The output is then a file where each line is a cluster of tab-separated
labels. MCL works natively with a numerical encoding of its input. This
<i>matrix input</i> is the second mode of operation. Label mode can save its
input for later use in matrix input. Here is how to do it.</p>
<pre>   <b>mcl</b> &lt;-|fname&gt; <a class="intern" href="#opt--abc"><b>--abc</b></a> <a class="intern" href="#opt-o"><b>-o</b>&nbsp;<i>fname-out</i></a>\
      <a class="intern" href="#opt-cache-tab"><b>-cache-tab</b>&nbsp;<i>map-name</i></a> <a class="intern" href="#opt-cache-graph"><b>-cache-graph</b>&nbsp;<i>graph-name</i></a></pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Native mode (matrix input) is entered simply by <i>not</i> specifying
<b>--abc</b>. The input file should then have been created by an earlier
invocation of <a class="intern" href="#opt-cache-graph"><b>-cache-graph</b>&nbsp;<i>fname</i></a> or by other means,
e.g. <a class="local" href="mcxload.html">mcxload</a>. It is
possible to obtain label output in native mode by specifying a label
dictionary, possibly one that was saved earlier using the
<a class="intern" href="#opt-cache-tab"><b>-cache-tab</b>&nbsp;<i>fname</i></a> option. An example is this:</p>
<pre>   <b>mcl</b> &lt;-|fname&gt; <a class="intern" href="#opt--yield-abc"><b>--yield-abc</b></a> <a class="intern" href="#opt-o"><b>-o</b>&nbsp;<i>fname-out</i></a>\
      <a class="intern" href="#opt-strict-tab"><b>-strict-tab</b>&nbsp;<i>fname-map</i></a></pre>
<p class="default L50" style="margin-bottom:0">
Here <b>-strict-tab</b> tells mcl that the input should not contain
labels other than found in the file <b>saved-mapping</b>. It is possible to
relax this by using <a class="intern" href="#opt-restrict-tab"><b>-restrict-tab</b>&nbsp;<i>fname-map</i></a> or
<a class="intern" href="#opt-extend-tab"><b>-extend-tab</b>&nbsp;<i>fname-map</i></a>.
</p>
<p class="default L50" style="margin-bottom:0">
Label mode is very convenient for easy and fast exploration. A decided
advantage of full native mode (where both graph input and cluster output are
in matrix format) is that the data can easily be analyzed and subjected to
further processing. Second, input that is stored in native binary format
loads much faster than label data when the input data size grows large. If
neither of these is of concern then label mode may be entirely sufficient.
For more information on label mode and native mode refer to examples in this
manual and <a class="local" href="mcxio.html">mcxio</a>.</p>
<p class="default L50" style="margin-bottom:0"><b>Granularity</b><br>
If you want to explore cluster structure in graphs with MCL, do use
the <a class="intern" href="#opt-I"><b>-I</b>&nbsp;<i>inflation</i></a> option with varying parameters
to obtain clusterings at different levels of granularity.</p>
<p class="default L50" style="margin-bottom:0"><b>Clustering from blast files</b><br>
Refer to the group of options discussed with
<a class="intern" href="#opt--abc"><b>--abc</b></a>. By way of a small example, consider these.</p>
<pre>mcxdeblast --abc-out=- hsfsp.blast | mcl - --abc -o -
mcxdeblast --m9 --abc-out=- hsfsp.blast | mcl - --abc -o -</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
The single hyphens in this example (other than word-separators)
indicate that output is written to STDOUT or read from STDIN.
The blast files are respectively in default and column (-m8 or -m9) format.
They are parsed, the output is sent to mcl, and mcl sends a list of
tab-separated labels to STDOUT. All the <tt>abc</tt> strings serve to indicate
that the mode of communication between these programs is <i>label format</i>.
It is possible to cache the input graph in native mcl matrix format:</p>
<pre>mcxdeblast --abc-out=- hsfsp.blast | \
   mcxload -abc - --mirror -o hsfsp.mcx -cache-tab hsfsp.tab --binary
mcl hsfsp.mcx -use-tab hsfsp.tab -o  hsfsp.my-nice-clustering</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
The matrix is written in binary format to speed up
subsequent reads. The speed-up factor is approximately ten-fold.
For large graphs it is recommended to use binary format.
Keep in mind though that it is not portable across machines
and is not garantueed to be portable across different versions
of mcl or differently compiled versions of mcl.
<b>mcl</b> also accepts the <a class="intern" href="#opt--binary"><b>--binary</b></a> option, ensuring that
graphs written with <a class="intern" href="#opt-cache-graph"><b>-cache-graph</b></a> are output in binary
format.
The <a class="local" href="mcxload.html">mcxload</a> <b>--mirror</b> option ensures that
the resulting graph is undirected. Input graphs that
are cached with mcl's <a class="intern" href="#opt-cache-graph"><b>-cache-graph</b></a> option
get the same treatment.</p>

<a name="synopsis"></a>
<h2>SYNOPSIS</h2>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
The example invocation below assumes matrix input, as described in the
<a class="local" href="mcxio.html">mcxio</a> section. Switching to label mode requires the input file to be in
label format and the addition of the <a class="intern" href="#opt--abc"><b>--abc</b></a> option.</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> &lt;-|fname&gt;
<a class="intern" href="#opt-I"><b>[-I</b> f (<i>inflation</i>)<b>]</b></a>
<a class="intern" href="#opt-o"><b>[-o</b> str (<i>fname</i>)<b>]</b></a>
<a class="intern" href="#opt-scheme"><b>[-scheme</b> k (<i>resource scheme</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0">
These options are sufficient in 95 percent of the cases or more. The first
argument must be the name of a file containing a graph/matrix in the mcl
input format, or a hyphen to read from STDIN. With respect to clustering,
only the <a class="intern" href="#opt-I"><b>-I</b> option</a> and
<a class="intern" href="#opt-scheme"><b>-scheme</b> option</a> are relevant and the rest is
immaterial.
</p>
<p class="default L50" style="margin-bottom:0">
A mechanism for pipelines is supported (as of the first 1.003 release).
Refer to the <a class="intern" href="#pipeline">PIPELINES</a> section for more information.
A prepackaged pipeline for BLAST data is present in the form of
<a class="local" href="mclblastline.html">mclblastline</a>. As of release 1.006 a lightweight BLAST clustering
mechanism is also supported. <a class="intern" href="#started">GETTING STARTED</a> is a small introduction,
with some examples of using BLAST results.
</p>
<p class="default L50" style="margin-bottom:0">
The full listing of <b>mcl</b> options is shown below, separated
into parts corresponding with functional aspects such
as clustering, threading, verbosity, pruning and resource management,
automatic output naming, and dumping.
The <b>-scheme</b> parameter provides a single access point to the
pruning options, and should be sufficient in most cases.
<b>mcl</b> allows comprehensive tuning and access to its internals
for those who are interested, so it has many options.
</p>
<p class="default L50" style="margin-bottom:0"><b>Baseline clustering options</b><br>
<a class="intern" href="#opt-I"><b>[-I</b> f (<i>inflation</i>)<b>]</b></a>
<a class="intern" href="#opt-o"><b>[-o</b> str (<i>fname</i>)<b>]</b></a>
<a class="intern" href="#opt-scheme"><b>[-scheme</b> k (<i>resource scheme</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Stream options</b><br>
<a class="intern" href="#opt--abc"><b>[--abc</b> fname (<i>expect/write labels</i>)<b>]</b></a>
<a class="intern" href="#opt--expect-abc"><b>[--expect-abc</b> (<i>expect labels</i>)<b>]</b></a>
<a class="intern" href="#opt--yield-abc"><b>[--yield-abc</b> fname (<i>write labels</i>)<b>]</b></a>
<a class="intern" href="#opt-use-tab"><b>[-use-tab</b> fname (<i>use mapping to write</i>)<b>]</b></a>
<a class="intern" href="#opt-strict-tab"><b>[-strict-tab</b> fname (<i>use mapping to enforce</i>)<b>]</b></a>
<a class="intern" href="#opt-restrict-tab"><b>[-restrict-tab</b> fname (<i>use mapping to restrict</i>)<b>]</b></a>
<a class="intern" href="#opt-extend-tab"><b>[-extend-tab</b> fname (<i>use mapping and extend</i>)<b>]</b></a>
<a class="intern" href="#opt-cache-tab"><b>[-cache-tab</b> fname (<i>write mapping</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Transform options</b><br>
<a class="intern" href="#opt-tf"><b>[-tf</b> &lt;tf-spec&gt; (<i>transform input matrix values</i>)<b>]</b></a>
<a class="intern" href="#opt-stream-tf"><b>[-stream-tf</b> &lt;tf-spec&gt; (<i>transform input stream values</i>)<b>]</b></a>
<a class="intern" href="#opt--stream-log"><b>[--stream-log</b> (<i>take logarithm of stream values</i>)<b>]</b></a>
<a class="intern" href="#opt--stream-neg-log"><b>[--stream-neg-log</b> (<i>take negative logarithm of stream values</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Cache options</b><br>
<a class="intern" href="#opt-cache-graph"><b>[-cache-graph</b> fname (<i>write graph</i>)<b>]</b></a>
<a class="intern" href="#opt-cache-expanded"><b>[-cache-expanded</b> fname (<i>write expanded graph</i>)<b>]</b></a>
<a class="intern" href="#opt-ei"><b>[-ei</b> inflation (<i>use with expanded input</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Additional clustering options</b><br>
<a class="intern" href="#opt-l"><b>[-l</b> n (<i>initial iteration number</i>)<b>]</b></a>
<a class="intern" href="#opt-L"><b>[-L</b> n (<i>main iteration number</i>)<b>]</b></a>
<a class="intern" href="#opt-i"><b>[-i</b> f (<i>initial inflation</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Input manipulation options</b><br>
<a class="intern" href="#opt-c"><b>[-c</b> f (<i>centering</i>)<b>]</b></a>
<a class="intern" href="#opt-pi"><b>[-pi</b> f (<i>pre-inflation</i>)<b>]</b></a>
<a class="intern" href="#opt-pp"><b>[-pp</b> n (<i>preprune count</i>)<b>]</b></a>
<a class="intern" href="#opt-in-gq"><b>[-in-gq</b> f (<i>filter threshold</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Clustering result options</b><br>
<a class="intern" href="#opt-sort"><b>[-sort</b> str (<i>sort mode</i>)<b>]</b></a>
<a class="intern" href="#opt--keep-overlap"><b>[--keep-overlap=</b>y/n (<i>retain overlap</i>)<b>]</b></a>
<a class="intern" href="#opt--output-limit"><b>[--output-limit=</b>y/n (<i>write limit matrix</i>)<b>]</b></a>
<a class="intern" href="#opt--force-connected"><b>[--force-connected=</b>y/n (<i>analyze components</i>)<b>]</b></a>
<a class="intern" href="#opt--check-connected"><b>[--check-connected=</b>y/n (<i>analyze components</i>)<b>]</b></a>
<a class="intern" href="#opt--analyze"><b>[--analyze=</b>y/n (<i>performance criteria</i>)<b>]</b></a>
<a class="intern" href="#opt--show-log"><b>[--show-log=</b>y/n (<i>show log</i>)<b>]</b></a>
<a class="intern" href="#opt--append-log"><b>[--append-log=</b>y/n (<i>append log</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Verbosity options</b><br>
<a class="intern" href="#opt-v"><b>[-v</b> str (<i>verbosity type on</i>)<b>]</b></a>
<a class="intern" href="#opt-V"><b>[-V</b> str (<i>verbosity type off</i>)<b>]</b></a>
<a class="intern" href="#opt--silent"><b>[--silent</b> (<i>very</i>)<b>]</b></a>
<a class="intern" href="#opt--verbose"><b>[--verbose</b> (<i>very</i>)<b>]</b></a>
<a class="intern" href="#opt-progress"><b>[-progress</b> k (<i>gauge</i>)<b>]</b></a>
<a class="intern" href="#opt--show"><b>[--show</b> (<i>print (small) matrices to screen</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Thread options</b><br>
<a class="intern" href="#opt-te"><b>[-te</b> k (<i>#expansion threads</i>)<b>]</b></a>
<a class="intern" href="#opt-ti"><b>[-ti</b> k (<i>#inflation threads</i>)<b>]</b></a>
<a class="intern" href="#opt-t"><b>[-t</b> k (<i>#threads</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Output file name options</b><br>
<a class="intern" href="#opt-o"><b>[-o</b> str (<i>fname</i>)<b>]</b></a>
<a class="intern" href="#opt-ap"><b>[-ap</b> str (<i>use str as file name prefix</i>)<b>]</b></a>
<a class="intern" href="#opt-aa"><b>[-aa</b> str (<i>append str to suffix</i>)<b>]</b></a>
<a class="intern" href="#opt-az"><b>[-az</b> (<i>show output file name and exit</i>)<b>]</b></a>
<a class="intern" href="#opt-ax"><b>[-ax</b> (<i>show output suffix and exit</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Dump options</b><br>
<a class="intern" href="#opt-dump-interval"><b>[-dump-interval</b> i:j (<i>dump interval</i>)<b>]</b></a>
<a class="intern" href="#opt-dump-modulo"><b>[-dump-modulo</b> k (<i>dump modulo</i>)<b>]</b></a>
<a class="intern" href="#opt-dump-stem"><b>[-dump-stem</b> stem (<i>dump file stem</i>)<b>]</b></a>
<a class="intern" href="#opt-dump"><b>[-dump</b> str (<i>type</i>)<b>]</b></a>
<a class="intern" href="#opt-dump-subi"><b>[-dump-subi</b> spec (<i>index list for submatrix dump</i>)<b>]</b></a>
<a class="intern" href="#opt-dump-subd"><b>[-dump-subd</b> spec (<i>domain list for submatrix dump</i>)<b>]</b></a>
<a class="intern" href="#opt-dump-dom"><b>[-dump-dom</b> fname (<i>domain matrix file</i>)<b>]</b></a>
<a class="intern" href="#opt-digits"><b>[-digits</b> n (<i>printing precision</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Info options</b><br>
<a class="intern" href="#opt--jury-charter"><b>[--jury-charter</b> (<i>explains jury</i>)<b>]</b></a>
<a class="intern" href="#opt--version"><b>[--version</b> (<i>show version</i>)<b>]</b></a>
<a class="intern" href="#opt-how-much-ram"><b>[-how-much-ram</b> k (<i>RAM upper bound</i>)<b>]</b></a>
<a class="intern" href="#opt-h"><b>[-h</b> (<i>most important options</i>)<b>]</b></a>
<a class="intern" href="#opt--apropos"><b>[--apropos</b> (<i>one-line description for all options</i>)<b>]</b></a>
<a class="intern" href="#opt-z"><b>[-z</b> (<i>show current settings</i>)<b>]</b></a>
<a class="intern" href="#opt-az"><b>[-az</b> (<i>show output file name and exit</i>)<b>]</b></a>
<a class="intern" href="#opt-ax"><b>[-ax</b> (<i>show output suffix and exit</i>)<b>]</b></a>
<a class="intern" href="#opt--show-schemes"><b>[--show-schemes</b> (<i>show resource schemes</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0"><b>Pruning options</b><br>
The following options all pertain to the various pruning strategies that can
be employed by <b>mcl</b>. They are described in the <a class="intern" href="#pruneoptions">PRUNING OPTIONS</a>
section, accompanied by a description of the mcl pruning strategy.
If your graphs are huge
and you have an appetite for tuning, have a look at the following:
</p>
<p class="default L50" style="margin-bottom:0">
<a class="intern" href="#opt-p"><b>[-p</b> f (<i>cutoff</i>)<b>]</b></a>
<a class="intern" href="#opt-P"><b>[-P</b> n (<i>1/cutoff</i>)<b>]</b></a>
<a class="intern" href="#opt-S"><b>[-S</b> n (<i>selection number</i>)<b>]</b></a>
<a class="intern" href="#opt-R"><b>[-R</b> n (<i>recovery number</i>)<b>]</b></a>
<a class="intern" href="#opt-pct"><b>[-pct</b> f (<i>recover percentage</i>)<b>]</b></a>
<a class="intern" href="#opt-my-scheme"><b>[-my-scheme</b> n (<i>tag custom scheme</i>)<b>]</b></a>
<a class="intern" href="#opt-warn-pct"><b>[-warn-pct</b> n (<i>prune warn percentage</i>)<b>]</b></a>
<a class="intern" href="#opt-warn-factor"><b>[-warn-factor</b> n (<i>prune warn factor</i>)<b>]</b></a>
<a class="intern" href="#opt--dense"><b>[--dense</b> (<i>allow matrices to fill</i>)<b>]</b></a>
<a class="intern" href="#opt--adapt"><b>[--adapt</b> (<i>pruning</i>)<b>]</b></a>
<a class="intern" href="#opt--rigid"><b>[--rigid</b> (<i>pruning</i>)<b>]</b></a>
<a class="intern" href="#opt-ae"><b>[-ae</b> f (<i>adaptive pruning exponent</i>)<b>]</b></a>
<a class="intern" href="#opt-af"><b>[-af</b> f (<i>adaptive pruning factor</i>)<b>]</b></a>
<a class="intern" href="#opt-nx"><b>[-nx</b> x (<i>x window index</i>)<b>]</b></a>
<a class="intern" href="#opt-ny"><b>[-ny</b> y (<i>y window index</i>)<b>]</b></a>
<a class="intern" href="#opt-nj"><b>[-nj</b> j (<i>jury window index</i>)<b>]</b></a>
<a class="intern" href="#opt-nw"><b>[-nw</b> w (<i>nr of windows</i>)<b>]</b></a>
<a class="intern" href="#opt-nl"><b>[-nl</b> w (<i>nr of iterations</i>)<b>]</b></a>
<a class="intern" href="#opt--thick"><b>[--thick</b> (<i>expect dense input graph</i>)<b>]</b></a>
</p>
<p class="default L50" style="margin-bottom:0">
The first argument of <b>mcl</b> must be a file name, but some options are allowed
to appear as the first argument instead. These are the options that cause
mcl to print out information of some kind, after which it will gracefully
exit. The full list of these options is
</p>
<p class="default L50" style="margin-bottom:0">
<a class="intern" href="#opt-z"><b>-z</b></a>,
<a class="intern" href="#opt-h"><b>-h</b></a>,
<a class="intern" href="#opt--apropos"><b>--apropos</b></a>,
<a class="intern" href="#opt--version"><b>--version</b></a>,
<a class="intern" href="#opt--show-settings"><b>--show-settings</b></a>,
<a class="intern" href="#opt--show-schemes"><b>--show-schemes</b></a>,
<a class="intern" href="#opt--jury-charter"><b>--jury-charter</b></a>,
<a class="intern" href="#opt-how-much-ram"><b>-how-much-ram</b>&nbsp;<i>k</i></a>.
</p>

<a name="description"></a>
<h2>DESCRIPTION</h2>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> implements the <b>MCL algorithm</b>, short for the <b>Markov cluster
algorithm</b>, a cluster algorithm for graphs developed by Stijn van Dongen at
the Centre for Mathematics and Computer Science in Amsterdam, the
Netherlands. The algorithm simulates flow using two simple algebraic
operations on matrices.
The inception of this flow process and the theory behind it are
described elsewhere (see <a class="intern" href="#references">REFERENCES</a>). Frequently asked questions
are answered in the <a class="local" href="mclfaq.html">mclfaq</a> section.
The program described here is a fast threaded implementation written by the
algorithm's creator with contributions by several others. Anton Enright
co-implemented threading; see the <a class="intern" href="#history">HISTORY/CREDITS</a> section for a complete
account.
See the <a class="intern" href="#applicability">APPLICABILITY</a> section for a description of the type of
graph mcl likes best, and for a qualitative assessment of its speed.
<b>mcl</b> is accompanied by several other utilities for analyzing clusterings and
performing matrix and graph operations; see the <a class="intern" href="#seealso">SEE ALSO</a> section.
</p>
<p class="default L50" style="margin-bottom:0">
The first argument is the input file name,
or a single hyphen to read from stdin. The rationale for
making the name of the input file a fixed parameter is that you typically do
several runs with different parameters. In command line mode it is
pleasant if you do not have to skip over an immutable parameter all the
time.
</p>
<p class="default L50" style="margin-bottom:0">
The <a class="intern" href="#opt-I"><b>-I</b>&nbsp;<i>f</i> option</a> is the main control,
affecting cluster granularity. Using <b>mcl</b> is as simple as
typing (assuming a file <i>proteins</i> contains a matrix/graph
in native matrix format)
</p>
<pre>mcl proteins -I 2.0</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
The above will result in a clustering written to the file
named <i>out.proteins.I20s2</i>. It is - of course -
possible to explicitly specify the name of the output file
using the <a class="intern" href="#opt-o"><b>-o</b>&nbsp;<i>fname</i></a> option. Refer to the
<a class="intern" href="#opt-ap"><b>-ap</b></a> option for a description of mcl's procedure
in automatically constructing file names from it parameters.
</p>
<p class="default L50" style="margin-bottom:0">
In native mode clusterings are stored as matrices
- this is discussed in the <a class="local" href="mcxio.html">mcxio</a> section.
You presumably want to convert the output to something that
is easier to interpret. The native mcl matrix format is perhaps
unpleasant to parse in the quick and dirty way. You can use
</p>
<pre>mcl proteins -I 2.0 -use-tab proteins.tab --yield-abc</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
to get a line/tab based output format,
each line containing a cluster in the form of tab-separated labels.
Here <b>proteins.tab</b> should be a tab file previously
created by <a class="local" href="mcxdeblast.html">mcxdeblast</a> or mcl.
Refer to <a class="local" href="mcxio.html">mcxio</a> for more information on tab files,
and the entries grouped under <a class="intern" href="#opt--abc"><b>--abc</b></a> for an extensive
discussion of the various ways in which mcl can combine
label format and matrix format in input and output.
</p>
<p class="default L50" style="margin-bottom:0">
In finding good <b>mcl</b> parameter settings for a particular domain,
or in finding cluster structure at different levels of granularity,
one typically runs mcl multiple times for varying values of f (refer
to the <a class="intern" href="#opt-I"><b>-I</b>&nbsp;<i>inflation</i></a> option for further information).
</p>
<p class="default L50" style="margin-bottom:0"><b>NOTE</b><br>mcl interprets the matrix
entries or graph edge weights as <b>similarities</b>, and it likes
<b>undirected input graphs</b> best. It can handle directed graphs, but any
node pair (i,j) for which w(i,j) is much smaller than w(j,i) or vice versa
will presumably have a slightly negative effect on the clusterings output by
mcl. Many such node pairs will have a distinctly negative effect, so try to
make your input graphs undirected. How your edge weights are computed may
affect mcl's performance. In protein clustering, one way to go is to
choose the negated logarithm of the BLAST probabilities (see
<a class="intern" href="#references">REFERENCES</a>).
</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b>'s default parameters should make it quite fast under almost all
circumstances. Taking default parameters, mcl has been used to generate
good protein clusters on 133k proteins, taking 10 minutes running time on a
Compaq ES40 system with four alpha EV6.7 processors. It has been applied
(with good results) to graphs with 800k nodes, and if you have the memory
(and preferably CPUs as well) nothing should stop you from going further.
</p>
<p class="default L50" style="margin-bottom:0">
For large graphs, there are several groups of parameters available for
tuning the mcl computing process, should it be necessary. The easiest thing
to do is just vary the <a class="intern" href="#opt-scheme"><b>-scheme</b> option</a>. This
triggers different settings for the group of pruning parameters
<a class="intern" href="#opt-P"><b>-p/-P</b>, <b>-R</b>, <b>-S</b>, and
<b>-pct</b></a>. The default setting corresponds with
<b>-scheme</b>&nbsp;<b>6</b>.
There is an additional group of control parameters
<a class="intern" href="#opt--adapt"><b>--adapt</b>, <b>--rigid</b>, <b>-ae</b>,
<b>-af</b></a>, which may be helpful in speeding up <b>mcl</b>.
When doing multiple mcl runs for the same graphs with different
<b>-I</b> settings (for obtaining clusterings at different levels
of granularity), it can be useful to factor out the first bit
of computation that is common to all runs, by using
the <a class="intern" href="#opt-cache-expanded"><b>-cache-expanded</b></a> option one time
and then using <a class="intern" href="#opt-ei"><b>-ei</b>&nbsp;<i>inflation</i></a> for each run in the set.
Whether mcl considers a graph large depends mainly on the graph
connectivity; a highly connected graph on 50,000 nodes is large to
mcl (so that you might want to tune resources) whereas a sparsely
connected graph on 500,000 nodes may be business as usual.
</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> is a memory munger. Its precise appetite depends on the resource
settings. You can get a rough (and usually much too pessimistic) upper
bound for the amount of RAM that is needed by using the
<a class="intern" href="#opt-how-much-ram"><b>-how-much-ram</b> option</a>. The corresponding
entry in this manual page contains the simple formula via which the upper
bound is computed.
</p>
<p class="default L50" style="margin-bottom:0">
Two other groups of interest are the thread-related
options (you can specify the number of threads to use)
<a class="intern" href="#opt-t"><b>-t</b>, <b>-te</b>, <b>-ti</b></a>,
and the verbosity-related options
<a class="intern" href="#opt--verbose"><b>--verbose</b>, <b>--silent</b>, <b>-v</b>,
<b>-V</b></a>.
The actual settings are shown with <b>-z</b>, and for graphs with
at most 12 nodes or so you can view the MCL matrix iterands on screen
by supplying <a class="intern" href="#opt--show"><b>--show</b></a> (this may give some
more feeling).
</p>
<p class="default L50" style="margin-bottom:0">
MCL iterands allow a generic interpretation as clusterings as well. The
clusterings associated with early iterands may contain a fair amount of
overlap. Refer to the <a class="intern" href="#opt-dump"><b>-dump</b> option</a>, the <a class="local" href="mclfaq.html">mclfaq</a>
manual, and the <a class="local" href="clmimac.html">clmimac</a> utility (Interpret Matrices As Clusterings).
Use <b>clmimac</b> only if you have a special reason; the normal usage of <b>mcl</b> is
to do multiple runs for varying <b>-I</b> parameters and use the
clusterings output by mcl itself.
</p>
<p class="default L50" style="margin-bottom:0">
Under very rare circumstances, <b>mcl</b> might get stuck in a seemingly infinite
loop. If the number of iterations exceeds a hundred and the <i>chaos</i>
indicator remains nearly constant (presumably around value 0.37), you can
force mcl to stop by sending it the ALRM signal (usually done
by <b>kill -s ALRM</b> <i>pid</i>). It will finish the current
iteration, and interpret the last iterand a clustering. Alternatively, you
can wait and mcl might converge by itself or it will certainly stop after
10,000 iterations (the default value for the <a class="intern" href="#opt-L"><b>-L</b></a> option). The
most probable explanation for such an infinite loop is that the input graph
contains the flip-flop graph of node size three as a subgraph.
</p>
<p class="default L50" style="margin-bottom:0">
The creator of this page feels that manual pages are a valuable resource,
that online html documentation is also a good thing to have, and
that info pages are way <i>way</i> ahead of their time. The
<a class="intern" href="#notes">NOTES</a> section explains how this page was created.
</p>
<p class="default L50" style="margin-bottom:0">
In the <a class="intern" href="#options">OPTIONS</a> section options are listed in order of
importance, with related options grouped together.
</p>

<a name="options"></a>
<h2>OPTIONS</h2>
<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td colspan=3><a name="opt-I"></a><b>-I</b> f (<i>inflation</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Sets the main inflation value to f. This value is the main handle
for affecting cluster granularity. It is usually chosen somewhere
in the range [1.2-5.0]. <b>-I</b>&nbsp;<b>5.0</b> will tend to result
in fine-grained clusterings, and <b>-I</b>&nbsp;<b>1.2</b> will tend to
result in very coarse grained clusterings. Your mileage will vary
depending on the characteristics of your data. That is why it is
a good idea to test the quality and coherency of your clusterings
using <a class="local" href="clmdist.html">clmdist</a> and <a class="local" href="clminfo.html">clminfo</a>. This will most likely reveal that
certain values of <b>-I</b> are simply not right for your data. The
<a class="local" href="clmdist.html">clmdist</a> section contains a discussion of how to use the cluster
validation tools shipped with <b>mcl</b> (see the <a class="intern" href="#seealso">SEE ALSO</a> section).
</p>
<p class="default L50" style="margin-bottom:0">
A second option for affecting cluster granularity is the
<a class="intern" href="#opt-c"><b>-c</b> option</a>.
It may possibly increase granularity.
</p>
<p class="default L50" style="margin-bottom:0">
With low values for <b>-I</b>, like <b>-I</b>&nbsp;<b>1.2</b>, you should be
prepared to use more resources in order to maintain quality of
clusterings, i.e. increase the argument to the
<a class="intern" href="#opt-scheme"><b>-scheme</b> option</a>.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-o"></a><b>-o</b> str (<i>fname</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Output the clustering to file named fname.
It is possible to send the clustering to stdout
by supplying <b>-o</b>&nbsp;<b>-</b>. If either one of <a class="intern" href="#opt--abc"><b>--abc</b></a>,
<a class="intern" href="#opt--yield-abc"><b>--yield-abc</b></a>, or <a class="intern" href="#opt-use-tab"><b>-use-tab</b>&nbsp;<i>tab-file</i></a>
is used the output will be in
label format - provided a tab file is specified or the input
is in label format.
Otherwise the clustering is output in the
mcl matrix format; see the <a class="local" href="mcxio.html">mcxio</a> section for
more information on this.
Refer also to the group of options
discussed at <a class="intern" href="#opt--abc"><b>--abc</b></a>.
</p>
<p class="default L50" style="margin-bottom:0">
Look at the <a class="intern" href="#opt-ap"><b>-ap</b>&nbsp;<i>prefix</i></a> option and its siblings for the
automatic naming constructions employed by <b>mcl</b> if the <b>-o</b> option is
not used.</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt--abc"></a><b>--abc</b> fname (<i>expect/write labels</i>)</td></tr><tr><td colspan=3 class=left><a name="opt--expect-abc"></a><b>--expect-abc</b> (<i>expect labels</i>)</td></tr><tr><td colspan=3 class=left><a name="opt--yield-abc"></a><b>--yield-abc</b> fname (<i>write labels</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-use-tab"></a><b>-use-tab</b> fname (<i>use mapping to write</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-strict-tab"></a><b>-strict-tab</b> fname (<i>use mapping to enforce</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-restrict-tab"></a><b>-restrict-tab</b> fname (<i>use mapping to restrict</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-extend-tab"></a><b>-extend-tab</b> fname (<i>use mapping and extend</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-cache-tab"></a><b>-cache-tab</b> fname (<i>write mapping</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
These items all relate to label input and/or label output.
<b>--abc</b> tells mcl to expect label input and output clusters
in terms of those labels.
It is equivalent to the combination of <b>--expect-abc</b>
and <b>--yield-abc</b>.
</p>
<p class="default L50" style="margin-bottom:0">
<b>-restrict-tab</b> and <b>-strict-tab</b>
can be used both with label input and native format.
When label input is used, they restrict, respectively require
labels to be present in the tab file.
When native input is used they restrict, respectively require
indices to be present in the tab domain.
<b>-strict-tab</b> fails in the face of exceptions, <b>-restrict-tab</b>
will simply ignore them.
<b>-strict-tab</b> and <b>-restrict-tab</b> do <i>not</i>
automatically yield label output. You need <b>--abc</b> or
<b>--yield-abc</b>.
</p>
<p class="default L50" style="margin-bottom:0">
<b>-extend-tab</b> is only useful when label input is used.
It will create a new label/index mapping when a label is not found
in the tab file. Presumably you want to use the <b>-cache-tab</b>
as well then.
</p>
<p class="default L50" style="margin-bottom:0">
<b>-use-tab</b> is only useful when matrix input is used.
It will use the tab file to convert the output to labels; it does
not hitch on indices missing from the tab file. Take a pick
from <b>-restrict-tab</b> or <b>-strict-tab</b> <i>and</i>
<b>--abc</b> or <b>--yield-abc</b> if that is what you want.
</p>
<p class="default L50" style="margin-bottom:0">
<b>-cache-tab</b> can be used to preserve the tab file
that was constructed from label input, either from scratch
or by extension from a previous tab file in case <b>-extend-tab</b>
was used.</p>
<p class="default L50" style="margin-bottom:0"><b>NOTE</b><br>
in all its dealings with tab files, mcl will only accept those
for which the associated domain is <i>canonical</i>, that is,
domains for which the indices range from zero to some number <tt>N</tt>
without omissions. It is possible to hook up any tab file to mcl,
but it requires mcxdump to act as an intermediary -
<a class="local" href="mcxdump.html">mcxdump</a> has no such limitations. This need in
general not be of concern to you. If a tab file is created by
mcl or mcxdeblast it will always be canonical.</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-tf"></a><b>-tf</b> &lt;tf-spec&gt; (<i>transform input matrix values</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-stream-tf"></a><b>-stream-tf</b> &lt;tf-spec&gt; (<i>transform input stream values</i>)</td></tr><tr><td colspan=3 class=left><a name="opt--stream-log"></a><b>--stream-log</b> (<i>take logarithm of stream values</i>)</td></tr><tr><td colspan=3 class=left><a name="opt--stream-neg-log"></a><b>--stream-neg-log</b> (<i>take negative logarithm of stream values</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
<b>-tf</b> transforms the values of the input matrix according
to <b>&lt;tf-spec&gt;</b>. <b>-stream-tf</b> transforms the stream values
(when <a class="intern" href="#opt--abc"><b>--abc</b></a> or <a class="intern" href="#opt--expect-abc"><b>--expect-abc</b></a> is used)
according to <b>&lt;tf-spec&gt;</b>.
<b>--neg-stream-log</b> and <b>--stream-log</b>
respectively imply that the stream input values are
first replaced by their (negative) logarithm.
The reason for their existence is documented in <a class="local" href="mcxio.html">mcxio</a>.
For a description of the transform language excpected/accepted
in <b>&lt;tf-spec&gt;</b> refer to the same.</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-cache-graph"></a><b>-cache-graph</b> fname (<i>write graph</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-cache-expanded"></a><b>-cache-expanded</b> fname (<i>write expanded graph</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-ei"></a><b>-ei</b> inflation (<i>use with expanded input</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">If you work with label input, <b>-cache-graph</b> can be
used to save the matrix mcl constructs. In a following
mcl invocation, you can use this graph rather than the label
input. This should greatly speed up matters. Presumably
the first time around you have use the <b>-cache-tab</b>&nbsp;<i>my.cache</i>
option. You can put that <tt>my.cache</tt> file to good use by
passing it in as <b>-use-tab</b>&nbsp;<i>my.cache</i> the second time around.
The session below puts everything together.</p>
<pre>mcl xyz.data --abc -I 2.0 -o xyz.cls-I20 --binary\
            -cache-graph xyz.mci -cache-tab xyz.tab
mcl xyz.mci -I 2.4 -use-tab xyz.tab -o xyz.cls-I24</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
The <a class="intern" href="#opt--binary"><b>--binary</b></a> option is useful for large graphs as it
will drastically speed up subsequent load times. Otherwise it
is not necessary, and bear in mind that binary format is not
portable across machines and it is not garantueed to be portable
across different version of mcl.
For very large graphs it could be a bit wasteful to load a large tab
structure into memory. The second line can then be replaced by</p>
<pre>mcl xyz.mci -I 2.4 -o -|\
mcxdump -imx - --no-values --dump-rlines\
            -tabr xyz.tab -o xyz.cls-I24</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Admittedly this is beginning to look like black magic, but truthfully
it is not, my dear paduan. <a class="local" href="mcxdump.html">mcxdump</a>
simply needs to be told how it should format its output. It needs to know
it should dump the matrix columns (clusters in this case) on a per-line
basis, that it should not dump the index that identifies the cluster
(an arbitrary rank in our case), and that there is no need to output
values.
<b>mcxdump</b> furthermore does not know how the tab file relates to
its input matrix, whereas mcl previously had the advantage of knowing.
Hence <b>-tabr</b> is telling mcxdump that the <i>row domain</i>
in the clustering matrix identify the nodes.</p>
<p class="default L50" style="margin-bottom:0">
The first step in almost any mcl run is that the matrix constructed from the
input is <i>squared</i> or <i>expanded</i>. This is a rather costly operation
if the input size is large. When you are doing multiple runs it can thus be
useful to cache the expanded matrix at the cost of a little more hassle.
Use <b>-cache-expanded</b>&nbsp;<i>fname</i> to write this matrix to <i>fname</i>.
In subsequent runs supply <i>fname</i> as the input argument to mcl and
use <b>-ei</b>&nbsp;<i>num</i> to indicate that the first thing to apply should be
inflation with parameter <i>num</i>. Combining our previous two
examples then yields</p>
<pre>mcl xyz.data --abc -I 2.0 -o xyz.cls-I20 --binary\
            -cache-expanded xyz.mxp -cache-tab xyz.tab
mcl xyz.mxp -ei 2.4 -I 2.4 -o -|\
mcxdump -imx - --no-values --dump-rlines\
            -tabr xyz.tab -o xyz.cls-I24</pre>
<p class="default L50" style="margin-bottom:0">Behold, this is a very time and space efficient setup.</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-scheme"></a><b>-scheme</b> k (<i>use a preset resource scheme</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
There are currently seven different resource schemes, indexed 1..7.
High schemes result in more expensive computations that may possibly be
more accurate. The default scheme is 4. When <b>mcl</b> is done, it will give a
grade (the so called <i>jury synopsis</i>) to the appropriateness of the
scheme used. <i>A low grade does not necessarily imply that the
resulting clustering is bad</i> - but anyway, a low grade should be reason
to try for a higher scheme. The grades are listed in the
<a class="intern" href="#pruneoptions">PRUNING OPTIONS</a> section under the
<a class="intern" href="#opt-nj"><b>-nj</b> option</a>.</p>
<p class="default L50" style="margin-bottom:0">
The <a class="intern" href="#pruneoptions">PRUNING OPTIONS</a> section contains an elaborate description
of the way <b>mcl</b> manages resources, should you be interested.
In case you are worried about the validation of the resulting
clusterings, the <a class="local" href="mclfaq.html">mclfaq</a> section
has several entries discussing this issue. The bottom line is
that you have to compare the clusterings resulting from different
schemes (and otherwise identical parameters) using utilities
such as <a class="local" href="clmdist.html">clmdist</a>, <a class="local" href="clminfo.html">clminfo</a> on the one hand, and your
own sound judgment on the other hand.
</p>
<p class="default L50" style="margin-bottom:0">
If your input graph is extremely dense, with an average node degree
(i.e. the number of neighbours per node) that is somewhere above
500, you may need to filter the input graph by removing the nodes
of highest degree (and projecting them back onto the resulting
clustering afterwards) or by using the
<a class="intern" href="#opt-pp"><b>-pp</b> option</a>.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--show-schemes"></a><b>--show-schemes</b> (<i>show preset resource schemes</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Shows the explicit settings to which the different preset schemes
correspond.
<p class="default L50" style="margin-bottom:0">
The characteristics are written in the same format (more or less) as
the output triggered by <a class="intern" href="#opt-v-pruning"><b>-v</b>&nbsp;<b>pruning</b></a>.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-c"></a><b>-c</b> f (<i>centering</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
The larger the value of f the more nodes are attached to themselves
rather than their neighbours, the more expansion (the spreading
of flow through the graph) is opposed, and the more fine-grained
clusterings tend to be. f should be chosen greater than or equal
to 1.0. The default is f=1.0. This option has a much weaker
effect than the <b>-I</b> option, but it can be useful depending
on your data.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-v"></a><b>-v</b> str (<i>verbosity type on</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
See the <b>--verbose</b> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-V"></a><b>-V</b> str (<i>verbosity type off</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
See the <b>--verbose</b> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--silent"></a><b>--silent</b> (<i>very</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
See the <b>--verbose</b> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--verbose"></a><b>--verbose</b> (<i>very</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
These are the different verbosity modes:
<p class="default L50" style="margin-bottom:0">
<b>progress</b><br>
<b>pruning</b><br>
<b>explain</b><br>
<b>clusters</b><br>
<b>all</b>
</p>
<p class="default L50" style="margin-bottom:0">
where <i>all</i> means all three previous modes.
<b>--verbose</b> and <b>-v</b>&nbsp;<b>all</b>
turn them all on, <b>--silent</b> and <b>-V</b>&nbsp;<b>all</b>
turn them all off. <b>-v</b>&nbsp;<i>str</i> and <b>-V</b>&nbsp;<i>str</i>
turn on/off the single mode <i>str</i> (for <i>str</i>
equal to one of <b>progress</b>, <b>pruning</b>, or <b>explain</b>).
Each verbosity mode is given its own entry below.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><b>-v</b>&nbsp;<b>progress</b></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
This mode causes <b>mcl</b> to emit a gauge
for each single matrix multiplication. It uses some
default length for the gauge, which can be altered by
the <b>-progress</b>&nbsp;<i>k</i> option. Simply using the latter
will also turn on this verbosity mode.
This mode can give you quickly an idea how long an mcl
run might take. If you use threading
(see the <a class="intern" href="#opt-t"><b>-t</b> option</a> and its friends),
this option may slow down the program a little (relative to
<b>-V</b>&nbsp;<b>progress</b>, not relative to a single-CPU mcl run).
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><b>-v</b>&nbsp;<b>explain</b></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
This mode causes the output of explanatory headers illuminating the
output generated with the <b>pruning</b> verbosity mode.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><b>-v</b>&nbsp;<b>pruning</b></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
This mode causes output of resource-related quantities. It has
<a class="intern" href="#opt-v-pruning">a separate entry in the PRUNING OPTIONS section</a>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><b>-v</b>&nbsp;<b>clusters</b></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
This mode prints a terse list of characteristics of the
clusterings associated with intermediate iterands.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-progress"></a><b>-progress</b> k (<i>gauge</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
If k&gt;0 then for each matrix multiplication <b>mcl</b> will print an
ascii gauge telling how far it is. The gauge will be (in some
cases approximately) k characters long. If k&lt;0 then mcl will
emit a gauge that is extended by one character after every |k|
vectors computed. For large graphs, this option has been known
to ease the pain of impatience. If k=0 then mcl will print a
message only after every matrix multiplication, and not during
matrix multiplication. This can be useful when you want mcl to be
as speedy as possible, for example when using parallellized mode
(as monitoring progress requires thread communication).
For parallellization (by threading) see the
<a class="intern" href="#opt-t"><b>-t</b> option</a>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-aa"></a><b>-aa</b> str (<i>append str to suffix</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
See the <b>-ap</b> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-ap"></a><b>-ap</b> str (<i>use str as file name prefix</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
If the <a class="intern" href="#opt-o"><b>-o</b>&nbsp;<i>fname</i></a> option is not used,
<b>mcl</b> will create a file name (for writing output to) that
should uniquely characterize the important parameters used in the
current invocation of mcl. The default format is <b>out.fname.suf</b>,
where <b>out</b> is simply the literal string <tt>out</tt>, <b>fname</b> is the
first argument containing the name of the file (with the graph) to be
clustered, and where <b>suf</b> is the suffix encoding a set of parameters
(described further below).
<p class="default L50" style="margin-bottom:0">
The <b>-ap</b>&nbsp;<i>str</i> option specifies a prefix to use
rather than <b>out.fname</b> as sketched above.
However, <b>mcl</b> will interpret the character '=', if present
in <i>str</i>, as a placeholder for the input file name.
</p>
<p class="default L50" style="margin-bottom:0">
If the <b>-aa</b>&nbsp;<i>str</i> option is used, <b>mcl</b> will append
<b>str</b> to the suffix <b>suf</b> created by itself.
You can use this if you need to encode some extra information in the
file name suffix.
</p>
<p class="default L50" style="margin-bottom:0">
The suffix is constructed as follows. The <b>-I</b>&nbsp;<i>f</i>
and <b>-scheme</b> parameter are always encoded.
The <b>-pi</b>&nbsp;<i>f</i>, <b>-l</b>&nbsp;<i>k</i>, <b>-i</b>&nbsp;<i>f</i>, and <b>-c</b>&nbsp;<i>f</i>
options are only encoded if they are used. Any real argument <i>f</i>
is encoded using <i>exactly one</i> trailing digit behind the decimal
separator (which itself is not written). The setting <b>-I</b>&nbsp;<b>3.14</b>
is thus encoded as I31. The <b>-scheme</b> option is encoded using the
letter 's', all other options mentioned here are encoded as themselves
(stripped of the hyphen). For example
</p>
<pre>mcl small.mci -I 3 -c 2.5 -pi 0.8 -scheme 5</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
results in the file name <tt>out.small.mci.I30s5c25pi08</tt>.
If you want to know beforehand what file name will be produced,
use the <b>-az</b> option.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-az"></a><b>-az</b> (<i>show output file name and exit</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-ax"></a><b>-ax</b> (<i>show output suffix and exit</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
If <b>mcl</b> automatically constructs a file name, it can be helpful to known
beforehand what that file name will be. Use <b>-az</b> and mcl will
write the file name to STDOUT and exit. This can be used if mcl is
integrated into other software for which the automatic creation of
unique file names is convenient.
<p class="default L50" style="margin-bottom:0">
By default MCL incorporates the input file name into the output file
name and appends a short suffix describing the most important
option settings. Use <b>-ax</b> to find out what that suffix is.
This can be useful in wrapper pipeline scripts such as clxcoarse.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-te"></a><b>-te</b> k (<i>#expansion threads</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
See the <b>-t</b>&nbsp;<i>k</i> option below.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-ti"></a><b>-ti</b> k (<i>#inflation threads</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
See the <b>-t</b>&nbsp;<i>k</i> option below.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-t"></a><b>-t</b> k (<i>#threads</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
The <b>-t</b> options are self-explanatory. Note that threading
inflation is hardly useful, as inflation is orders of magnitude
faster than expansion. Also note that threading is only useful
if you have a multi-processor system.
</p>
<p class="default L50" style="margin-bottom:0">
When threading, it is best not to turn on pruning verbosity
mode if you are letting mcl run unattended, unless you want to
scrutinize its output later. This is because it makes <b>mcl</b> run
somewhat slower, although the difference is not dramatic.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-l"></a><b>-l</b> n (<i>initial iteration number</i>) (small letter ell)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
The number of times <b>mcl</b> will use a different inflation value
before it switches to the (main) inflation given by the <b>-I</b>
(capital eye) option. The different value is called <i>initial
inflation</i> and is tunable using the <a class="intern" href="#opt-i"><b>-i</b>&nbsp;<i>f</i>
option</a> (default value f=2.0). The default value (to <b>-l</b>)
is zero. This option supplies new ways of affecting cluster
granularity, e.g. by supplying
<pre>mcl proteins -i 1.4 -l 2 -I 4.0</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
one lets expansion prevail during the first two iterations,
followed by inflation catching up (in a figurative way of writing).
This may be useful in certain cases, but this type of experiment
is <i>certainly secondary</i> to simply varying <b>-I</b> (capital eye).
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-L"></a><b>-L</b> n (<i>main iteration number</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Normally, <b>mcl</b> computes the MCL process until it has converged
fully to a doubly idempotent matrix. The number of iterations
required is typically somewhere in the range 10-100.
The first few iterations generally take the longest time.
The <b>-L</b> option can be used to specify the number of
iterations mcl may do at most. When this number is reached,
mcl will output the clustering associated with the iterand
last computed.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-i"></a><b>-i</b> f (<i>initial inflation</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
The inflation value used during the first n iterations,
where n is specified by the <b>-l</b> (ell) option.
By default, n=0 and f=2.0.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-pi"></a><b>-pi</b> f (<i>pre-inflation</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
If used, <b>mcl</b> will apply inflation one time to the input graph
before entering the main process. This can be useful for
making the edge weights in a graph either more homogeneous (which
may result in less granular clusterings) or more heterogeneous
(which may result in more granular clusterings).
Homogeneity is achieved for values <i>f</i> less than one,
heterogeneity for values larger than one.
Values to try are normally in the range <tt>[2.0,10.0]</tt>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-di"></a><b>-di</b> i:j (<i>dump interval</i>)</td></tr><tr><td colspan=3 class=left><b>-di</b>&nbsp;<i>all</i></td></tr><tr><td colspan=3 class=left><b>-dump-interval</b>&nbsp;<i>i:j</i></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Dump during iterations i..j-1. Use <i>all</i> to dump in all
iterations. See the <b>-dump</b>&nbsp;<i>str</i> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-dm"></a><b>-dm</b> k (<i>dump i+0..i+k..</i>)</td></tr><tr><td colspan=3 class=left><b>-dump-modulo</b>&nbsp;<i>k</i></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Sampling rate: select only these iterations in the dump interval.
See the <b>-dump</b>&nbsp;<i>str</i> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-ds"></a><b>-ds</b> stem (<i>file stem</i>)</td></tr><tr><td colspan=3 class=left><b>-dump-stem</b>&nbsp;<i>stem</i></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Set the the stem for file names of dumped
objects (default <i>mcl</i>). See the <b>-dump</b>&nbsp;<i>str</i> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-dump-subi"></a><b>-dump-subi</b> spec (<i>index list for submatrix dump</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-dump-subd"></a><b>-dump-subd</b> spec (<i>domain list for submatrix dump</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-dump-dom"></a><b>-dump-dom</b> fname (<i>domain matrix file</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<b>-dump-subi</b> specifies a range of indices which will be
used to select the extended principal submatrix.
Argument <i>spec</i> can be a comma-separated
list of single integers and integer ranges. Ranges are denoted by
two integers separated by a hyphen.
<p class="default L50" style="margin-bottom:0">
If <b>-dump-dom</b> is used and specifies a matrix file,
the indices specified in the <b>-dump-subd</b> option should index
columns in that matrix. These columns are merged and added to the
list of entries used in selecting the extended principal submatrix.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-dump"></a><b>-dump</b> str (<i>type</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<i>str</i> is checked for substring occurrences of the following entries.
Repeated use of <b>-dump</b> is also allowed.
<p class="default L50" style="margin-bottom:0">
<b>ite</b><br>
<b>dag</b><br>
<b>cls</b><br>
<b>chr</b><br>
<b>lines</b><br>
<b>cat</b>
</p>
<p class="default L50" style="margin-bottom:0">
<b>lines</b> and <b>cat</b> change the mode of dumping. The first
changes the dump format to a line based pairwise format rather
than the default mcl matrix format. The second causes all
dumped items to be dumped to the default stream used for the
output clustering, which is appended at the end.
</p>
<p class="default L50" style="margin-bottom:0">
The <b>ite</b> option writes <b>mcl</b> iterands to file. The <b>cls</b>
option writes clusterings associated with mcl iterands to file.
These clusters are obtained from a particular directed acyclic graph
(abbreviated as DAG) associated with each iterand. The <b>dag</b> option
writes that DAG to file. The DAG can optionally be further
pruned and then again be interpreted as a
clustering using <a class="local" href="clmimac.html">clmimac</a>, and <a class="local" href="clmimac.html">clmimac</a> can also
work with the matrices written using the <b>ite</b> option.
It should be noted that clusterings associated with intermediate
iterands may contain overlap, which is interesting in
many applications. For more information
refer to <a class="local" href="mclfaq.html">mclfaq</a> and the <a class="intern" href="#references">REFERENCES</a> section below.
</p>
<p class="default L50" style="margin-bottom:0">
The <b>result</b> option dumps the usual MCL clustering.
</p>
<p class="default L50" style="margin-bottom:0">
The <b>chr</b> option says, for each iterand I, to output a matrix C with
characteristics of I. C has the same number of columns as I. For each
column k in C, row entry 0 is the diagonal or 'loop' value of column k in
I <i>after</i> expansion and pruning, and <i>before</i> inflation and
rescaling. Entry 1 is the loop value <i>after</i> inflation and rescaling.
Entry 2 is the center of column k (the sum of its entries squared)
computed <i>after</i> expansion and <i>before</i> pruning, entry 3 is the
maximum value found in that column at the same time. Entry 4 is the
amount of mass kept for that column <i>after pruning</i>.
</p>
<p class="default L50" style="margin-bottom:0">
The <b>-ds</b> option sets the stem for file names of dumped
objects (default <i>mcl</i>). The <b>-di</b> and <b>-dm</b>
options allow a selection of iterands to be made.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-digits"></a><b>-digits</b> n (<i>printing precision</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
This has two completely different uses. It sets
the number of decimals used for pretty-printing <b>mcl</b> iterands
when using the <a class="intern" href="#opt--show"><b>--show</b> option</a> (see below),
and it sets the number of decimals used for writing
the expanded matrix when using the <a class="intern" href="#opt-cache-expanded"><b>-cache-expanded</b></a> option.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--show"></a><b>--show</b> (<i>print matrices to screen</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Print matrices to screen. The number of significant digits to be
printed can be tuned with <b>-digits</b>&nbsp;<i>n</i>. An 80-column screen
allows graphs (matrices) of size up to 12(x12) to be printed with
three digits precision (behind the comma), and of size up to 14(x14)
with two digits. This can give you an idea of how <b>mcl</b> operates,
and what the effect of pruning is.
Use e.g. <b>-S</b>&nbsp;<b>6</b> for such
a small graph and view the MCL matrix iterands with <b>--show</b>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--binary"></a><b>--binary</b> (<i>output format</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
Write matrix dump output in binary mcl format rather
than interchange mcl format (the default). Note that <a class="local" href="mcxconvert.html">mcxconvert</a>
can be used to convert each one into the other.
See <a class="local" href="mcxio.html">mcxio</a> and <a class="local" href="mcxconvert.html">mcxconvert</a> for more information.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-sort"></a><b>-sort</b> str (<i>sort mode</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
<i>str</i> can be one of <b>lex</b>, <b>size</b>, <b>revsize</b>,
or <b>none</b>. The default is 'revsize', in which the largest
clusters come first. If the mode is 'size', smallest clusters
come first, if the mode is 'lex', clusters are ordered
lexicographically, and if the mode is 'none', the order
is the same as produced by the procedure used by mcl to
map matrices onto clusterings.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--keep-overlap"></a><b>--keep-overlap</b> y/n (<i>retain overlap</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
The <b>keep-overlap</b> action causes mcl to retain overlap
should this improbable event occur. In theory, <b>mcl</b> may generate a
clustering that contains overlap, although this almost never happens
in practice, as it requires some particular type of symmetry to be present
in the input graph (not just any symmetry will do). Mathematically
speaking, this is a conjecture and not a theorem, but the present author wil
eat his shoe if it fails to be true (for marzipan values of shoe). It is
easy though to construct an input graph for which certain mcl settings
result in overlap - for example a line graph on an odd number of nodes. The
default is to remove overlap should it occur.
</p>
<p class="default L50" style="margin-bottom:0">
This option has more than theoretical use because <b>mcl</b> is able
to generate clusterings associated with intermediate iterands.
For these clusterings, overlap is more than a theoretical
possibility, and will often occur. If you specify
the <a class="intern" href="#opt-L"><b>-L</b>&nbsp;<i>k</i></a> option, mcl will output the
clustering associated with the last iterand computed, and
it may well contain overlap.
</p>
<p class="default L50" style="margin-bottom:0">
This option has no effect on the clusterings that are
output when using <a class="intern" href="#opt-dump"><b>-dump</b>&nbsp;<i>cls</i></a> -
the default for those is that overlap is not touched,
and this default can not yet be overridden.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt--force-connected"></a><b>--force-connected</b>=y/n (<i>analyze components</i>)</td></tr><tr><td colspan=3 class=left><a name="opt--check-connected"></a><b>--check-connected</b>=y/n (<i>analyze components</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
If the input graph has strong bipartite characteristics,
mcl may yield clusters that do not correspond to connected
components in the input graph. Turn one of these modes on to
analyze the resultant clustering.
<p class="default L50" style="margin-bottom:0">
If loose clusters are found
they will be split into subclusters corresponding to
connected components.
With <b>--force-connected</b>=<i>y</i> mcl will write the
corrected clustering to the normal output file, and the old clustering
to the same file with suffix <tt>orig</tt>.
With <b>--check-connected</b>=<i>y</i> mcl will write the
loose clustering to the normal output file, and the corrected clustering
to the same file with suffix <tt>coco</tt>.
</p>
<p class="default L50" style="margin-bottom:0">
These options are not on by default, as the analysis
is currently (overly) time-consuming
and mcl's behaviour actually makes some sense
(when taking bipartite characteristics into account).
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--output-limit"></a><b>--output-limit</b>=y/n (<i>write limit matrix</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
This will write the limit matrix to a file named
<b>base</b>-limit.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--analyze"></a><b>--analyze</b>=y/n (<i>performance criteria</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
With this mode turned on, <b>mcl</b> will reread the input matrix
and compute a few performance criteria and attach them to
the output file. Off by default.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--append-log"></a><b>--append-log</b>=y/n (<i>append log</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Appends a log with the process characteristics to the output file.
By default, this mode is on.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--show-log"></a><b>--show-log</b>=y/n (<i>show log</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Shows the log with process characteristics on STDOUT.
By default, this mode is off.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-in-gq"></a><b>-in-gq</b> f (<i>filter threshold</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
mcl will remove any edges in the input graph (equivalently, entries in
the input matrix) for which the weight is below&nbsp;<i>f</i>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-pp"></a><b>-pp</b> n (<i>preprune count</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
For each column vector (node) in the input matrix (graph) <b>mcl</b> will
keep the n entries (outgoing edges) of that vector (node) that
have largest weight and remove the rest.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--jury-charter"></a><b>--jury-charter</b> (<i>explains jury</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Explains how the jury synopsis is computed from the jury marks.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--version"></a><b>--version</b> (<i>show version</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Show version.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-how-much-ram"></a><b>-how-much-ram</b> n (<i>RAM upper bound</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<b>n</b> is interpreted as the number of nodes of an input graph.
mcl will print the maximum amount of RAM it needs for its computations.
The formula for this number in bytes is:
<pre>   2 * c * k * n

   2  :  two matrices are concurrently held in memory.
   c  :  mcl cell size (as shown by -z).
   n  :  graph cardinality (number of nodes).
   k  :  MAX(s, r).
   s  :  select number (-S, -scheme options).
   r  :  recover number (-R, -scheme options).</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
This estimate will usually be too pessimistic. It does assume though that
the average node degree of the input graph does not exceed k. The
<b>-how-much-ram</b> option takes other command-line arguments into
account (such as <b>-S</b> and <b>-R</b>), and it expresses the
amount of RAM in megabyte units.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-h"></a><b>-h</b> (<i>show help</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Shows a selection of the most important <b>mcl</b> options.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--apropos"></a><b>--apropos</b> (<i>show help</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Gives a one-line description for all options.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--show-settings"></a><b>--show-settings</b> (<i>show settings</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
A synonym for the <a class="intern" href="#opt-z"><b>-z</b> option</a>.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-z"></a><b>-z</b> (<i>show settings</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Show current settings for tunable parameters.
<b>--show-settings</b> is a synonym.
</div></td></tr>
</table>

</div>

<a name="pruneoptions"></a>
<h2>PRUNING OPTIONS</h2>
<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td colspan=3 class=left><a name="opt-p"></a><b>-p</b> f (<i>cutoff</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-P"></a><b>-P</b> n (<i>1/cutoff</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-S"></a><b>-S</b> s (<i>selection number</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-R"></a><b>-R</b> r (<i>recover number</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-pct"></a><b>-pct</b> pct (<i>recover percentage</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-my-scheme"></a><b>-my-scheme</b> n (<i>tag custom scheme</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
After computing a new (column stochastic) matrix vector during expansion
(which is matrix multiplication c.q. squaring), the vector is
successively exposed to different pruning strategies. The intent of
pruning is that many small entries are removed while retaining much of
the stochastic mass of the original vector. After pruning, vectors are
rescaled to be stochastic again. MCL iterands are theoretically known to
be sparse in a weighted sense, and this manoever effectively perturbs the
MCL process a little in order to obtain matrices that are genuinely
sparse, thus keeping the computation tractable. An example of monitoring
pruning can be found in the discussion of
<a class="intern" href="#opt-v-pruning"><b>-v</b>&nbsp;<b>pruning</b></a>
at the end of this section.
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> proceeds as follows. First, entries that are smaller than
<i>cutoff</i> are removed, resulting in a vector with at most
<i>1/cutoff</i> entries. The cutoff can be supplied either by
<b>-p</b>, or as the inverse value by <b>-P</b>. The latter is more
intuitive, if your intuition is like mine (and the P stands for precision
or pruning by the way).
The cutoff just described is rigid; it is the same for all vectors. The
<a class="intern" href="#opt--adapt"><b>--adapt</b> option</a> causes the computation of a
cutoff that depends on a vector's homogeneity properties, and this option
may or may not speed up mcl.
</p>
<p class="default L50" style="margin-bottom:0">
Second, if the remaining stochastic mass (i.e. the sum of all remaining
entries) is less than <i>pct</i>/100 and the number of remaining
entries is less than <i>r</i> (as specified by the <b>-R</b> flag),
<b>mcl</b> will try to regain ground by recovering the largest discarded
entries. The total number of entries is not allowed to grow larger than
<i>r</i>.
If recovery was not necessary, mcl tries to prune the vector further
down to at most <i>s</i> entries (if applicable), as specified by the
<b>-S</b> flag. If this results in a vector that satisfies the recovery
condition then recovery is attempted, exactly as described above. The
latter will not occur of course if <i>r</i> &lt;= <i>s</i>.
</p>
<p class="default L50" style="margin-bottom:0">
The default setting is something like <b>-P</b>&nbsp;<b>4000</b> <b>-S</b>&nbsp;<b>500</b>
<b>-R</b>&nbsp;<b>600</b>. Check the <b>-z</b> flag to be sure. There is a set
of precomposed settings, which can be triggered with the
<a class="intern" href="#opt-scheme"><b>-scheme</b>&nbsp;<i>k</i> option</a>. <i>k</i>=4 is the default
scheme; higher values for <i>k</i> result in costlier and more accurate
computations (vice versa for lower, cheaper, and less accurate).
The schemes are listed using the <b>--show-schemes</b> option. It is
advisable to use the <b>-scheme</b> option only in interactive mode,
and to use the explicit expressions when doing batch processing. The
reason is that there is <i>no guarantee whatsoever</i> that the schemes
will not change between different releases. This is because the scheme
options should reflect good general purpose settings, and it may become
appararent that other schemes are better.
</p>
<p class="default L50" style="margin-bottom:0">
Note that 'less accurate' or 'more accurate' computations may still
generate the same output clusterings. Use <b>clmdist</b> to compare output
clusterings for different resource parameters. Refer to <a class="local" href="clmdist.html">clmdist</a>
for a discussion of this issue.
</p>
<p class="default L50" style="margin-bottom:0">
The <b>-my-scheme</b>&nbsp;<b>n</b> option sets a tag that is used in constructing
the default output naming file. If not used, <b>mcl</b> will create
a relatively long string describing the settings of the
<b>-P</b>, <b>-pct</b>, <b>-R</b>, and <b>-S</b> parameters,
e.g. <b>P600Q85R1000S1200</b> (where <b>Q</b> tags the <i>pct</i> setting).
If used, mcl will simply use the tag <b>s</b><i>n</i>.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-warn-pct"></a><b>-warn-pct</b> k (<i>prune warn percentage</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-warn-factor"></a><b>-warn-factor</b> k (<i>prune warn factor</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
The two options <b>-warn-pct</b> and <b>-warn-factor</b> relate to
warnings that may be triggered once the <i>initial</i> pruning of a vector
is completed. The idea is to issue warnings if initial pruning almost
completely destroys a computed vector, as this may be a sign that the
pruning parameters should be changed. It depends on the mass remaining
after initial pruning whether a warning will be issued. If that mass is
less than <i>warn-pct</i> or if the number of remaining entries is smaller
by a factor <i>warn-factor</i> than both the number of entries originally
computed <i>and</i> the recovery number, in that case, <b>mcl</b> will issue a
warning.
<p class="default L50" style="margin-bottom:0">
<b>-warn-pct</b> takes an integer between 0 and 100 as parameter,
<b>-warn-factor</b> takes a real positive number. They default to
something like 30 and 50.0. If you want to see less warnings, decrease
<i>warn-pct</i> and increase <i>warn-factor</i>. Set <i>warn-factor</i> to zero
if you want no warnings.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--dense"></a><b>--dense</b> (<i>allow matrices to fill</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
This renders all pruning options useless except for one. After each
expansion step, <b>mcl</b> will remove all entries that are smaller than the
threshold specified by <b>-p</b> or <b>-P</b>, which acts like a
precision in this case. After removal, the matrix columns are rescaled
to be stochastic again.
<p class="default L50" style="margin-bottom:0">
If the <b>-p</b> threshold (precision) is zero or very small,
the <b>--dense</b> option results in a rather accurate and very
costly computation of the MCL process. Do not use this option
for graphs with more than several thousands of entries, or you will
have trouble digging your processor out of swap.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--rigid"></a><b>--rigid</b> (<i>pruning</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
See the <b>--adapt</b> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-ae"></a><b>-ae</b> f (<i>adaptive pruning exponent</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
See the <b>--adapt</b> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-af"></a><b>-af</b> f (<i>adaptive pruning factor</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
See the <b>--adapt</b> option below.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--adapt"></a><b>--adapt</b> (<i>pruning</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
The default <b>mcl</b> pruning behaviour as described under
the <a class="intern" href="#opt-P"><b>-P</b> option</a> is called <i>rigid pruning</i>
(it being the default renders the switch <b>--rigid</b>
currently useless), refering to the fact that the first stage
of pruning removes entries smaller than a fixed threshold.
The options discussed here enable the computation of a threshold that
depends on the homogeneity characteristics of a vector. This behaviour is
triggered by supplying <b>--adapt</b>.
<p class="default L50" style="margin-bottom:0">
The <b>--adapt</b> behaviour only affects the first pruning stage, c.q.
the computation of the first threshold (see the discussion under the
<a class="intern" href="#opt-P"><b>-P</b> option</a>). It does not interfere with either
selection or recovery. It is affected however by the threshold as
specified by the <b>-P</b> option. When using <b>--adapt</b>, you
typically use the <b>-P</b> option as well, and you can and should use
a higher value then you would without using <b>--adapt</b>.
</p>
<p class="default L50" style="margin-bottom:0">
All that said, <b>--adapt</b> triggers this behaviour: Given a
stochastic vector v, its mass center of order two is computed,
which is the sum of each entry squared. The mass center of v,
call it c, is strongly related to its homogeneity properties
(see <a class="intern" href="#references">REFERENCES</a>). The threshold T is computed as 1/f *
pow(c, e), where e and f are the arguments to the <b>-af</b>&nbsp;<i>f</i>
and <b>-ae</b>&nbsp;<i>e</i> options respectively (check <b>-z</b>
for the respective defaults).
For either e or f decreasing it means that T becomes larger.
<i>Finally, T is maxed with the rigid threshold value</i>, which
can be altered using either <b>-p</b>&nbsp;<i>f</i> or <b>-P</b>&nbsp;<i>n</i>.
The latter is why you should increase the <b>-P</b> parameter n
(so that the rigid threshold is decreased) once you switch to
adaptive pruning. The adaptive threshold should be the main factor
controlling pruning, with the rigid threshold acting as a safeguard
that does not take over too often.
</p>
<p class="default L50" style="margin-bottom:0">
This may seem complicated, but the rules are actually quite simple, and
you may just disregard the definition of T. The usefulness of these
options will vary. If you want to speed up <b>mcl</b>, try it out
and add <b>--adapt</b> to your settings.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt--thick"></a><b>--thick</b> (<i>expect dense input graph</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
This option is somewhat esoteric. It does not affect the matrices as
computed by <b>mcl</b>, but it affects the way in which they are computed. If
the input graph is very dense, this may speed up mcl a little.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-v-pruning"></a><b>-v</b>&nbsp;<b>pruning</b></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Pruning verbosity mode causes <b>mcl</b> to emit several statistics related to
the pruning process, each of which is described below. Use
<b>-v</b>&nbsp;<b>explain</b> to get explanatory headers in the output as well
(or simply use <b>-v</b>&nbsp;<b>all</b>).
<p class="default L50" style="margin-bottom:0"><b>Selection and recovery</b><br>
The number of selections and recoveries <b>mcl</b> had to perform during each
iteration is shown. It also shows the number of vectors for which the
mass after final pruning was below the fraction defined by the
<a class="intern" href="#opt-pct"><b>-pct</b> option</a> as a percentage (default probably 90
or 95).
</p>
<p class="default L50" style="margin-bottom:0"><b>Initial and pruned vector footprint distributions</b><br>
The distribution of the vector footprints (i.e. the number of nonzero
entries) before and after pruning is shown. This is assembled in a terse
(horrid if you will) format, looking as follows (with some context
stripped, noting that the data for three expansion steps is shown):
</p>
<pre>----------------------------------------------------
 mass percentages  | distr of vec footprints       |
         |         |____ expand ___.____ prune ____|
  prune  | final   |e4   e3   e2   |e4  e3   e2    |
all ny nx|all ny nx|8532c8532c8532c|8532c8532c8532c|
---------.---------.---------------.---------.-----.
 98 88 86  98 91 86 _________022456 ___________0234
 98 89 86  98 94 91 _______00245678 ___________0234
 98 90 89  99 95 94 _______00235568 ___________0234
 ...</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
This particular output was generated (and truncated after three rounds of
expansion and inflation) from clustering a protein graph on 9058 nodes
with settings <b>-I</b>&nbsp;<b>1.4</b>, <b>-P</b>&nbsp;<b>2000</b>, <b>-S</b>&nbsp;<b>500</b>,
<b>-R</b>&nbsp;<b>600</b>, and <b>-pct</b>&nbsp;<b>95</b>.
</p>
<p class="default L50" style="margin-bottom:0">
The header entries 8532c85.. indicate thresholds going from 80000, 50000,
20000, 12500, 8000, all the way down to 300, 200, and 125. The character
'c' signifies the base 1.25 (for no apparent reason). The second entry
'2' (after '0') on the first line signifies that roughly 20 percent of
all the vectors had footprint (#nonzero entries) between 800 and 1250.
Likewise, 40 percent had footprint between 300 and 500. The '0' entries
signify a fraction somewhere below 5 percent, and the '@' entries signify
a fraction somewhere above 95 percent.
</p>
<p class="default L50" style="margin-bottom:0">
Two columns are listed, one for the expansion vector footprints
(i.e. after squaring), and the other for the vector
footprints <i>right after initial pruning took place</i> (i.e. before
selection and recovery, after either adaptive or rigid pruning).
This may give an idea of the soundness of the initial pruning
process (overly severe, or overly mild), and the extent
to which you want to apply selection and/or recovery.
</p>
<p class="default L50" style="margin-bottom:0"><b>Initial and final mass windows</b><br>
The mass averages of the pruned vectors after the first selection
stage are shown, and the mass averages of the vectors as <i>finally
computed</i>, i.e. after selection and recovery. Note that the latter
corresponds to a different stage than what is shown for the vector
footprints, if either selection or recovery is turned on.
For both cases, three averages are shown: the average over all vectors,
the average over the worst x cases, and the average over the worst y
cases. The mass averages are shown as percentages: '98' on the first
line under the 'prune/all' column means that overall 98 percent of the
stochastic mass of the matrix was kept after pruning.
</p>
<p class="default L50" style="margin-bottom:0">
This example demonstrates that many entries could be
removed while retaining much of the stochastic mass. The effect of the
recovery (<b>-R</b>) parameter is also clear: the final averages are
higher than the initial averages, as a result of <b>mcl</b> undoing some
overenthousiastic pruning.
</p>
<p class="default L50" style="margin-bottom:0">
An average over the worst k cases is called a window of width k;
internally, <b>mcl</b> tracks many more such windows. The result of this can
be seen when using the <a class="intern" href="#opt--append-log"><b>--append-log</b>=<b>y</b></a> option
(which appends a log to the cluster output) or the
<a class="intern" href="#opt--show-log"><b>--show-log</b>=<b>y</b> option</a>
(which sends the log to STDOUT).
From a fixed set of windows those that are applicable are tracked, that
is, all those windows for which the width does not exceed the graph
cardinality. The windows in the fixed set have respective sizes 1, 2, 5,
10, 20, 50, and so on up until 5000000 (which makes 15 windows in all).
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3 class=left><a name="opt-nx"></a><b>-nx</b> i (<i>x window index</i>)</td></tr><tr><td colspan=3 class=left><a name="opt-ny"></a><b>-ny</b> j (<i>y window index</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
The options <b>-nx</b> and <b>-ny</b>
both take an index in the range 1..15. The default values
for <b>-nx</b> and <b>-ny</b> are respectively 4 and 7,
denoting the fourth and seventh window of respective widths
10 and 100. They are used in the verbosity output as
described above.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-nj"></a><b>-nj</b> i (<i>jury window index</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
The <b>-nj</b> denotes a window index in the same way as <b>-nx</b>
and <b>-ny</b> do. This particular window is used for computing the
<i>jury marks</i>, which are the three number reported by <b>mcl</b> when it is
done. They are a reminder of the existence of pruning and its importance
for both speed and accuracy, and they are <i>indicative rather than
authorative</i>.
<p class="default L50" style="margin-bottom:0">
These jury marks are simply the respective mass averages in the jury
window for the first three iterations. The marks are even further
simplified and mapped to the jury synopsis, which is a single grade
expressed as an adjective. The grades are, in decreasing order of
achievement, <i>perfect exceptional superior excellent good acceptable
mediocre poor bad lousy miserable awful wretched atrocious</i>. Doing 'mcl
--jury-charter' will tell you how the jury marks map onto the jury
synopsis.
</p>
<p class="default L50" style="margin-bottom:0">
The jury marks should preferably be higher than 70. If they are in the
vicinity of 80 or 90, <b>mcl</b> is doing fine as far as pruning is concerned.
Choose a higher scheme if you think them too low. For very dense graphs
that do have strong cluster structure, the jury marks can sink as low as
to the 30's and 40's, but the clusterings generated by mcl may still be
good. The marks and the synopsis grade the severity of pruning, not
cluster quality. Note that the jury becomes friendlier, resp. harsher
when the <b>-nj</b> option is increased/decreased.
</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-nw"></a><b>-nw</b> w (<i>nr of windows</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
Normally, <b>mcl</b> will use all windows that have width smaller
than the cardinality of the input graph. This option limits
the set of windows to those w windows of smallest width.
This affects the output when setting
<a class="intern" href="#opt--append-log"><b>--append-log</b>=<b>y</b></a> output.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3><a name="opt-nl"></a><b>-nl</b> l (<i>number of iterations</i>)</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
By default, <b>mcl</b> will log the window mass averages for the first ten
iterations. This options sets that number to&nbsp;<b>l</b>.
It affects the <a class="intern" href="#opt--append-log"><b>--append-log</b>=<b>y</b></a> output.
</div></td></tr>
</table>

</div>

<a name="pipeline"></a>
<h2>PIPELINES</h2>
<p class="default L50" style="margin-bottom:0">
As of the 1.006 release, label data can be directly streamed into
MCL as described in <a class="intern" href="#started">GETTING STARTED</a> and <a class="intern" href="#examples">EXAMPLES</a>.
For BLAST input this is achieved
by hooking up <a class="local" href="mcxdeblast.html">mcxdeblast</a> <b>--abc-out</b>=<i>-</i> with
<b>mcl</b> - <b>--abc</b>. Refer to <a class="intern" href="#started">GETTING STARTED</a> for examples.</p>
<p class="default L50" style="margin-bottom:0">
The classic mode of operation is more heavyweight, and the remainder
of this section describes the underlying design.
Much of the code now used for streaming directly into mcl was
derived from this earlier framework.</p>
<p class="default L50" style="margin-bottom:0">
In general, clustering requires several stages; creating the matrix,
running mcl, and displaying the result. The display stage is supported
by <a class="local" href="clmformat.html">clmformat</a>. The matrix creation stage often needs only be
done once for a given data collection, followed by repeated runs of
the other two stages for varying inflation values and scheme settings.</p>
<p class="default L50" style="margin-bottom:0">
The matrix creation stage can often be split up in two more stages,
namely parsing a data file in some given format, and assembling a
matrix from the data bits and pieces, such as node indices and edge
weights or even edge weight contributions.
The assembly step can be done by <a class="local" href="mcxassemble.html">mcxassemble</a>,
which allows a very general input format and customizable behaviour
in how the bits and pieces should be transformed to the input graph.
This leaves the parse stage to be filled in.</p>
<p class="default L50" style="margin-bottom:0">
The <a class="local" href="mclpipeline.html">mclpipeline script</a> implements a generic and
customizable pipeline encapsulating the four stages distinguished
here (parsing, assembly, clustering, display). It is possible to
let only part of the pipeline be active, and many other features are
supported. The IO mechanism is entirely file based, and files are
associated with parametrizations via file name extensions (by all
means a simple mechanism).</p>
<p class="default L50" style="margin-bottom:0">
<a class="local" href="mclpipeline.html">mclpipeline</a> requires a single parse script to be specified.
It will be plugged into the pipeline and you should be set to run.
The parse script must satisfy the interface requirements described
in the <a class="local" href="mclpipeline.html">mclpipeline manual page</a>.</p>
<p class="default L50" style="margin-bottom:0">
For BLAST input, the <a class="local" href="mclblastline.html">mclblastline script</a>
provides a dedicated mclpipeline interface. It uses the
<a class="local" href="mcxdeblast.html">mcxdeblast script</a> that comes prepackaged with mcl.</p>

<a name="examples"></a>
<h2>EXAMPLES</h2>
<p class="default L50" style="margin-bottom:0">The following is an example of label input</p>
<pre>---8&lt;------8&lt;------8&lt;------8&lt;------8&lt;---
cat hat  0.2
hat bat  0.16
bat cat  1.0
bat bit  0.125
bit fit  0.25
fit hit  0.5
hit bit  0.16
---&gt;8------&gt;8------&gt;8------&gt;8------&gt;8---</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">It can be clustered like this:</p>
<pre>mcl cathat --abc -o out.cathat</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">The file out.cathat should now like like this</p>
<pre>---8&lt;------8&lt;------8&lt;------8&lt;------8&lt;---
cat hat bat
bit fit hit
---&gt;8------&gt;8------&gt;8------&gt;8------&gt;8---</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">A few things to note. First, MCL will symmetrize any
arrow it finds. If it sees <tt>bat cat 1.0</tt> it will act as if it also
saw <tt>cat bat 1.0</tt>. You can explicitly specify <tt>cat bat 1.0</tt>,
mcl will in the first parse stage simply end up with duplicate
entries. Second, MCL deduplicates repeated edges by taking the
one with the maximum value. So,</p>
<pre>---8&lt;------8&lt;------8&lt;------8&lt;------8&lt;---
cat hat  0.2
hat cat  0.16
hat cat  0.8
---&gt;8------&gt;8------&gt;8------&gt;8------&gt;8---</pre>
<p class="default L50" style="margin-top:0em; margin-bottom:0em">Will result in two arrows <tt>cat-hat</tt> and <tt>hat-cat</tt> both
with value 0.8.</p>

<a name="applicability"></a>
<h2>APPLICABILITY</h2>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> will work very well for graphs in which the diameter of the natural
clusters is not too large. The presence of many edges between different
clusters is not problematic; as long as there is cluster structure, mcl
will find it. It is less likely to work well for graphs with clusters
(inducing subgraphs) of large diameter, e.g. grid-like graphs derived from
Euclidean data. So mcl in its canonical form is certainly not fit for
boundary detection or image segmentation. I experimented with a modified
mcl and boundary detection in the thesis pointed to below (see
<a class="intern" href="#references">REFERENCES</a>). This was fun and not entirely unsuccesful, but not
something to be pursued further.
</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> likes <i>undirected input graphs best</i>, and it really dislikes graphs
with node pairs (i,j) for which an arc going from i to j is present and the
counter-arc from j to i is absent. Try to make your input graph undirected.
Furthermore, mcl interprets edge weights in graphs as similarities. If you
are used to working with dissimilarities, you will have to convert those to
similarities using some conversion formula. The most important thing is
that you feel confident that the similarities are reasonable, i.e. if X is
similar to Y with weight 2, and X is similar to Z with weight 200, then this
should mean that the similarity of Y (to X) is neglectible compared with the
similarity of Z (to X).
</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> is probably not suited for clustering <i>tree graphs</i>. This is because
mcl works best if there are multiple paths between different nodes in the
natural clusters, but in tree graphs there is only one path between any pair
of nodes. Trees are too sparse a structure for mcl to work on.
</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> may well be suited for clustering <i>lattices</i>. It will depend
on the density characteristics of the lattice, and the conditions for
success are the same as those for clustering graphs in general: The
diameter of the natural clusters should not be too large.
<b>NOTE</b> when clustering a lattice, you <i>have</i> to cluster
the underlying undirected graph, and not the directed graph that represents
the lattice itself. The reason is that one has to allow mcl (or any other
cluster algorithm) to 'look back in time', so to speak. Clustering and
directionality bite each other (long discussion omitted).
</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> has a worst-case time complexity O(N*k^2), where N is the number of
nodes in the graph, and k is the maximum number of neighbours tracked during
computations. k depends on the <b>-P</b> and <b>-S</b> options. If the
<b>-S</b> option is used (which is the default setting) then k equals the
value corresponding with this option. Typical values for k are in the range
500..1000. The average case is much better than the worst case though, as
cluster structure itself has the effect of helping mcl's pruning schemes,
certainly if the diameter of natural clusters is not large.
</p>

<a name="files"></a>
<h2>FILES</h2>
<p class="default L50" style="margin-bottom:0">
There are currently no resource nor configuration files.
The mcl matrix format is described in the <a class="local" href="mcxio.html">mcxio</a> section.
</p>

<a name="environment"></a>
<h2>ENVIRONMENT</h2>
<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td colspan=3>MCLXINTERCHANGEDIGITS</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
When writing matrices in interchange format, mcl will use the environment
variable MCLXINTERCHANGEDIGITS (if present) as the precision (number of
digits) for printing the fractional part of values.</p>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3>MCLXIOVERBOSITY</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
<p class="default L50" style="margin-top:0em; margin-bottom:0em">
MCL and its sibling applications will usually report about matrix
input/output from/to disk. The verbosity level can be regulated
via MCLXIOVERBOSITY. These are the levels it can currently be set to.</p>
<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=right>1</td><td width=16>&nbsp;</td><td><div style="text-align:justify"> Silent but applications may alter this.
</div></td></tr><tr><td width=32 valign="top" class=right>2</td><td width=16>&nbsp;</td><td><div style="text-align:justify"> Silent and applications can not alter this.
</div></td></tr><tr><td width=32 valign="top" class=right>4</td><td width=16>&nbsp;</td><td><div style="text-align:justify"> Verbose but applications may alter this.
</div></td></tr><tr><td width=32 valign="top" class=right>8</td><td width=16>&nbsp;</td><td><div style="text-align:justify"> Verbose and applications can not alter this (default).
</div></td></tr>
</table>

</div>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3>MCLXIOFORMAT</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
MCL and its sibling applications will by default output matrices
in interchange format rather than binary format (cf. <a class="local" href="mcxio.html">mcxio</a>).
The desired format can be controlled via the variable
MCLXIOFORMAT. These are the levels it can currently be set to.
<div style="margin-top:1em">
<table
cellspacing="0" border=0
cellpadding="0" summary="itemize">
<tr><td width=32 valign="top" class=right>1</td><td width=16>&nbsp;</td><td><div style="text-align:justify"> Interchange format but applications may alter this.
</div></td></tr><tr><td width=32 valign="top" class=right>2</td><td width=16>&nbsp;</td><td><div style="text-align:justify"> Interchange format and applications can not alter this (default).
</div></td></tr><tr><td width=32 valign="top" class=right>4</td><td width=16>&nbsp;</td><td><div style="text-align:justify"> Binary format but applications may alter this.
</div></td></tr><tr><td width=32 valign="top" class=right>8</td><td width=16>&nbsp;</td><td><div style="text-align:justify"> Binary format and applications can not alter this.
</div></td></tr>
</table>

</div>
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3>MCLXINTERCHANGEFLAGS</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
If matrices are output in interchange format, by default empty vectors
will not be listed. Equivalently (during input time),
vectors for which no listing is present are understood to be empty -
note that the <i>presence</i> of a vector is established using
the domain information found in the header part.
It is possible to enforce listing of empty vectors by
setting bit '1' in the variable MCLXINTERCHANGEFLAGS.
</div></td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td></td></tr><tr><td colspan=3>MCLXIOUNCHECKED</td></tr><tr><td width=32>&nbsp;</td><td width=8>&nbsp;</td><td><div style="text-align:justify">
MCL and its sibling applications will always check a matrix for consistency
while it is being read. If this variable is set, the consistency check is
omitted. For large graphs the speed up can be considerable. However, if the
input graph is not conforming it will likely crash the application that
is using it.
</div></td></tr>
</table>

</div>

<a name="diagnostics"></a>
<h2>DIAGNOSTICS</h2>
<p class="default L50" style="margin-bottom:0">
If <b>mcl</b> issues a diagnostic error, it will most likely be
because the input matrix could not be parsed succesfully.
<b>mcl</b> tries to be helpful in describing the kind of parse error.
The mcl matrix format is described in the <a class="local" href="mcxio.html">mcxio</a> section.
</p>

<a name="bugs"></a>
<h2>BUGS</h2>
<p class="default L50" style="margin-bottom:0">
No known bugs at this time. Please send bug reports to mcl-devel@micans.org.
</p>

<a name="author"></a>
<h2>AUTHOR</h2>
<p class="default L50" style="margin-bottom:0">
Stijn van Dongen.
</p>

<a name="history"></a>
<h2>HISTORY/CREDITS</h2>
<p class="default L50" style="margin-bottom:0">
The MCL algorithm was conceived in spring 1996 by the present author.
The first implementation of the MCL algorithm followed that spring
and summer. It was written in Perl and proved the viability of
the algorithm. The implementation described here began its life in
autumn 1997. The first versions of the vital matrix library
were designed jointly by Stijn van Dongen and Annius Groenink in
the period Oktober 1997 - May 1999. The efficient matrix-vector
multiplication routine was written by Annius. This routine is
without significant changes still one of the cornerstones of this
MCL implementation.
</p>
<p class="default L50" style="margin-bottom:0">
Since May 1999 all MCL libraries have seen much development and
redesign by the present author. Matrix-matrix multiplication has been
rewritten several times to take full advantage of the sparseness
properties of the stochastic matrices brought forth by the MCL
algorithm. This mostly concerns the issue of pruning - removal of
small elements in a stochastic column in order to keep matrices
sparse.
</p>
<p class="default L50" style="margin-bottom:0">
Very instructive was that around April 2001 Rob Koopman pointed out
that selecting the k largest elements out of a collection of n is
best done using a min-heap. This was the key to the second major
rewrite (now counting three) of the MCL pruning schemes, resulting in
much faster code, generally producing a more accurate computation of
the MCL process.
</p>
<p class="default L50" style="margin-bottom:0">
In May 2001 Anton Enright initiated the parallellization of the
<b>mcl</b> code and threaded inflation. From this example, Stijn threaded
expansion. This was great, as the MCL data structures and operands
(normal matrix multiplication and Hadamard multiplication) just beg
for parallellization.
</p>
<p class="default L50" style="margin-bottom:0">
Onwards.
The January 2003 03-010 release introduced support for sparsely
enumerated (i.e. indices need not be sequential) graphs and matrices, the
result of a major overhaul of the matrix library and most higher layers.
Conceptually, the library now sees matrices as infinite quadrants
of which only finite subsections happen to have nonzero entries.
</p>
<p class="default L50" style="margin-bottom:0">
The June 2003 03-154 release introduced unix-type pipelines for clustering,
including the BLAST parser mcxdeblast and the mclblastline script.
The April 2004 04-105 release revived binary format, which has been a first
class citizen every since.</p>
<p class="default L50" style="margin-bottom:0">
With the March 2005 05-090 release mcxsubs finally acquired a sane
specification syntax. The November 2005 05-314 release brought the ability
to stream label input directly into mcl. The subsequent release introduced a
transformation language shared by various mcl siblings that allows arbitrary
progressions of transformations to be applied to either stream values or
matrix values.</p>
<p class="default L50" style="margin-bottom:0">
Joost van Baal set up the mcl CVS tree and packaged mcl for Debian
GNU/Linux. He completely autotooled the sources, so much so that at first I
found it hard to find them back amidst bootstrap, aclocal.m4, depcomp, and
other beauties.
</p>
<p class="default L50" style="margin-bottom:0">
Jan van der Steen shared his elegant mempool code. Philip Lijnzaad gave
useful comments. Philip, Shawn Hoon, Abel Ureta-Vidal,
and Martin Mokrejs sent helpful bug reports.
</p>
<p class="default L50" style="margin-bottom:0">
Abel Ureta-Vidal and Dinakarpandian Deendayal commented on
and contributed to mcxdeblast and mcxassemble.
</p>
<p class="default L50" style="margin-bottom:0">
Tim Hughes contributed several good bug reports for mcxassemble,
mcxdeblast and zoem (a workhorse for clmformat).
</p>

<a name="seealso"></a>
<h2>SEE ALSO</h2>
<p class="default L50" style="margin-bottom:0">
<a class="local" href="mclfaq.html">mclfaq</a> - Frequently Asked Questions.
</p>
<p class="default L50" style="margin-bottom:0">
<a class="local" href="mcxio.html">mcxio</a> - a description of the mcl matrix format.
</p>
<p class="default L50" style="margin-bottom:0">
There are many more utilities. Consult
<a class="local" href="mclfamily.html">mclfamily</a> for an overview of and links to all the documentation
and the utilities in the mcl family.
</p>
<p class="default L50" style="margin-bottom:0">
<b>mcl</b> development is discussed on <tt>mcl-devel@lists.micans.org</tt>,
(subscribtion) information is at
<a class="extern" href="https://lists.micans.org:446/listinfo/mcl-devel">https://lists.micans.org:446/listinfo/mcl-devel</a> , this list is
archived at <a class="extern" href="https://lists.micans.org:446/pipermail/mcl-devel/">https://lists.micans.org:446/pipermail/mcl-devel/</a>.
</p>
<p class="default L50" style="margin-bottom:0">
mcl's home at <a class="extern" href="http://micans.org/mcl/">http://micans.org/mcl/</a>.
</p>

<a name="references"></a>
<h2>REFERENCES</h2>
<p class="default L50" style="margin-bottom:0">
Stijn van Dongen, <i>Graph Clustering by Flow Simulation</i>.
PhD thesis, University of Utrecht, May 2000.<br>
<a class="extern" href="http://www.library.uu.nl/digiarchief/dip/diss/1895620/inhoud.htm">http://www.library.uu.nl/digiarchief/dip/diss/1895620/inhoud.htm</a>
</p>
<p class="default L50" style="margin-bottom:0">
Stijn van Dongen. <i>A cluster algorithm for graphs</i>.
Technical Report INS-R0010, National Research Institute for Mathematics and
Computer Science in the Netherlands, Amsterdam, May 2000.<br>
<a class="extern" href="http://www.cwi.nl/ftp/CWIreports/INS/INS-R0010.ps.Z">http://www.cwi.nl/ftp/CWIreports/INS/INS-R0010.ps.Z</a>
</p>
<p class="default L50" style="margin-bottom:0">
Stijn van Dongen. <i>A stochastic uncoupling process for graphs</i>.
Technical Report INS-R0011, National Research Institute for Mathematics and
Computer Science in the Netherlands, Amsterdam, May 2000.<br>
<a class="extern" href="http://www.cwi.nl/ftp/CWIreports/INS/INS-R0011.ps.Z">http://www.cwi.nl/ftp/CWIreports/INS/INS-R0011.ps.Z</a>
</p>
<p class="default L50" style="margin-bottom:0">
Stijn van Dongen. <i>Performance criteria for graph clustering and Markov
cluster experiments</i>. Technical Report INS-R0012, National Research
Institute for Mathematics and Computer Science in the Netherlands,
Amsterdam, May 2000.<br>
<a class="extern" href="http://www.cwi.nl/ftp/CWIreports/INS/INS-R0012.ps.Z">http://www.cwi.nl/ftp/CWIreports/INS/INS-R0012.ps.Z</a>
</p>
<p class="default L50" style="margin-bottom:0">
Enright A.J., Van Dongen S., Ouzounis C.A.
<i>An efficient algorithm for large-scale detection of protein families</i>,
Nucleic Acids Research 30(7):1575-1584 (2002).
</p>

<a name="notes"></a>
<h2>NOTES</h2>
<p class="default L50" style="margin-bottom:0">
This page was generated from <b>ZOEM</b> manual macros,
<a class="extern" href="http://micans.org/zoem">http://micans.org/zoem</a>. Both html and roff pages can be created
from the same source without having to bother with all the usual conversion
problems, while keeping some level of sophistication in the typesetting.
<a class="local" href="mcl.ps">This</a> is the PostScript derived from the zoem troff
output.
</p>
</body>
</html>
